<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.physics.brillouinzone &mdash; sisl 0.1.dev1+ga8efd77 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> sisl
          </a>
              <div class="version">
                0.1.dev1+ga8efd77
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/scripts.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>sisl.physics.brillouinzone</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.physics.brillouinzone</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="sd">&quot;&quot;&quot;Brillouin zone classes</span>
<span class="sd">=========================</span>

<span class="sd">The Brillouin zone objects are all special classes enabling easy manipulation</span>
<span class="sd">of an underlying physical quantity.</span>

<span class="sd">Quite often a physical quantity will be required to be averaged, or calculated individually</span>
<span class="sd">over a number of k-points. In this regard the Brillouin zone objects can help.</span>

<span class="sd">The BrillouinZone object allows direct looping of contained k-points while invoking</span>
<span class="sd">particular methods from the contained object.</span>
<span class="sd">This is best shown with an example:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">&gt;&gt;&gt; bz.apply.array.eigh()</span>

<span class="sd">This will calculate eigenvalues for all k-points associated with the `BrillouinZone` and</span>
<span class="sd">return everything as an array. The `~sisl.physics.BrillouinZone.dispatch` property of</span>
<span class="sd">the `BrillouinZone` object has several use cases (here ``array`` is shown).</span>

<span class="sd">This may be extremely convenient when calculating band-structures:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bs = BandStructure(H, [[0, 0, 0], [0.5, 0, 0]], 100)</span>
<span class="sd">&gt;&gt;&gt; bs_eig = bs.apply.array.eigh()</span>
<span class="sd">&gt;&gt;&gt; plt.plot(bs.lineark(), bs_eig)</span>

<span class="sd">and then you have all eigenvalues for all the k-points along the path.</span>

<span class="sd">Sometimes one may want to post-process the data for each k-point.</span>
<span class="sd">As an example lets post-process the DOS on a per k-point basis while</span>
<span class="sd">calculating the average:</span>
<span class="sd"> </span>
<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    # Calculate the velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    V = (v ** 2).sum(1)</span>
<span class="sd">...    return DOS.reshape(-1, 1) * v ** 2 / V.reshape(-1, 1)</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.apply.average.eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">This will, calculate the Monkhorst pack k-averaged DOS split into 3 Cartesian</span>
<span class="sd">directions based on the eigenstates velocity direction. This method of manipulating</span>
<span class="sd">the result can be extremely powerful to calculate many quantities while running an</span>
<span class="sd">efficient `BrillouinZone` average. The `eta` flag will print, to stdout, a progress-bar.</span>
<span class="sd">The usage of the ``wrap`` method are also passed optional arguments, ``parent`` which is</span>
<span class="sd">``H`` in the above example. ``k`` and ``weight`` are the current k-point and weight of the</span>
<span class="sd">corresponding k-point. An example could be to manipulate the DOS depending on the k-point and</span>
<span class="sd">weight:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate, k, weight):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates and weight by k_x and weight</span>
<span class="sd">...    return eigenstate.DOS(E) * k[0] * weight</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.apply.sum.eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">When using wrap to calculate more than one quantity per eigenstate it may be advantageous</span>
<span class="sd">to use `~sisl.oplist` to handle cases of `BrillouinZone.apply.average` and `BrillouinZone.apply.sum`.</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_multiple(eigenstate):</span>
<span class="sd">...    # Calculate DOS/PDOS for eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    PDOS = eigenstate.PDOS(E)</span>
<span class="sd">...    # Calculate velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    return oplist([DOS, PDOS, v])</span>
<span class="sd">&gt;&gt;&gt; DOS, PDOS, v = mp.apply.average.eigenstate(wrap=wrap_multiple, eta=True)</span>

<span class="sd">Which does mathematical operations (averaging/summing) using `~sisl.oplist`.</span>


<span class="sd">Parallel calculations</span>
<span class="sd">---------------------</span>

<span class="sd">The ``apply`` method looping k-points may be explicitly parallelized.</span>
<span class="sd">To run parallel do:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=True) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">This requires you also have the package ``pathos`` available.</span>
<span class="sd">The above will run in parallel using a default number of processors</span>
<span class="sd">in priority:</span>

<span class="sd">1. Environment variable ``SISL_NUM_PROCS``</span>
<span class="sd">2. Return value of ``os.cpu_count()``.</span>

<span class="sd">Note that this may interfere with BLAS implementation which defaults</span>
<span class="sd">to use all CPU&#39;s for threading. The total processors/threads that will</span>
<span class="sd">be created is ``SISL_NUM_PROCS * OMP_NUM_THREADS``. Try and ensure this is below</span>
<span class="sd">or equal to the actual core-count of your machine (or the number of requested</span>
<span class="sd">cores in a HPC environment).</span>


<span class="sd">Alternatively one can control the number of processors locally by doing:</span>

<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=2) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">which will request 2 processors (regardless of core-count).</span>
<span class="sd">As a last resort you can pass your own ``Pool`` of workers that</span>
<span class="sd">will be used for the parallel processing.</span>

<span class="sd">&gt;&gt;&gt; from multiprocessing import Pool</span>
<span class="sd">&gt;&gt;&gt; pool = Pool(4)</span>
<span class="sd">&gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=pool) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">The ``Pool`` should implement some standard methods that are</span>
<span class="sd">existing in the ``pathos`` enviroment such as ``Pool.restart`` and ``Pool.terminate``</span>
<span class="sd">and ``imap`` and ``uimap`` methods. See the ``pathos`` documentation for detalis.</span>


<span class="sd">   BrillouinZone</span>
<span class="sd">   MonkhorstPack</span>
<span class="sd">   BandStructure</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">cross</span><span class="p">,</span> <span class="n">argsort</span>

<span class="kn">from</span> <span class="nn">sisl._internal</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span> <span class="nn">sisl.oplist</span> <span class="kn">import</span> <span class="n">oplist</span>
<span class="kn">from</span> <span class="nn">sisl.unit</span> <span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span> <span class="nn">sisl.quaternion</span> <span class="kn">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span> <span class="nn">sisl.utils.mathematics</span> <span class="kn">import</span> <span class="n">cart2spher</span><span class="p">,</span> <span class="n">fnorm</span>
<span class="kn">from</span> <span class="nn">sisl.utils.misc</span> <span class="kn">import</span> <span class="n">allow_kwargs</span>
<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="kn">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">progressbar</span><span class="p">,</span> <span class="n">deprecate_method</span><span class="p">,</span> <span class="n">deprecate</span>
<span class="kn">from</span> <span class="nn">sisl.supercell</span> <span class="kn">import</span> <span class="n">SuperCell</span>
<span class="kn">from</span> <span class="nn">sisl.grid</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">sisl._dispatcher</span> <span class="kn">import</span> <span class="n">ClassDispatcher</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">xarray</span>
    <span class="n">_has_xarray</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">_has_xarray</span> <span class="o">=</span> <span class="kc">False</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BrillouinZone&quot;</span><span class="p">,</span> <span class="s2">&quot;MonkhorstPack&quot;</span><span class="p">,</span> <span class="s2">&quot;BandStructure&quot;</span><span class="p">,</span> <span class="s2">&quot;linspace_bz&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">BrillouinZoneDispatcher</span><span class="p">(</span><span class="n">ClassDispatcher</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Loop over all k-points by applying `parent` methods for all k.</span>

<span class="sd">    This allows potential for running and collecting various computationally</span>
<span class="sd">    heavy methods from a single point on all k-points.</span>

<span class="sd">    The `apply` method will *dispatch* the parent methods through all k-points</span>
<span class="sd">    and passing `k` as arguments to the parent methods in a straight-forward manner.</span>

<span class="sd">    For instance to iterate over all eigenvalues of a Hamiltonian</span>

<span class="sd">    &gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">    &gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">    &gt;&gt;&gt; for ik, eigh in enumerate(bz.apply.eigh()):</span>
<span class="sd">    ...    # do something with eigh which corresponds to bz.k[ik]</span>

<span class="sd">    By default the `apply` method exposes a set of dispatch methods:</span>

<span class="sd">    - `apply.iter`, the default iterator module</span>
<span class="sd">    - `apply.average` reduced result by averaging (using `BrillouinZone.weight` as the weight per k-point.</span>
<span class="sd">    - `apply.sum` reduced result without weighing</span>
<span class="sd">    - `apply.array` return a single array with all values; has `len` equal to number of k-points</span>
<span class="sd">    - `apply.none`, specialized method that is mainly useful when wrapping methods</span>
<span class="sd">    - `apply.list` same as `apply.array` but using Python list as return value</span>
<span class="sd">    - `apply.oplist` using `sisl.oplist` allows greater flexibility for mathematical operations element wise</span>
<span class="sd">    - `apply.datarray` if `xarray` is available one can retrieve an `xarray.DataArray` instance</span>

<span class="sd">    Please see :ref:`physics.brillouinzone` for further examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">linspace_bz</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jumps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jump_dk</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convert points from a BZ object into a linear spacing of maximum value `stop`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bz : BrillouinZone, or ndarray</span>
<span class="sd">       the object containing the k-points</span>
<span class="sd">    stop : int or None, optional</span>
<span class="sd">       maximum value in the linear space, or if None, will return the cumulative</span>
<span class="sd">       distance of the k-points in the Brillouin zone</span>
<span class="sd">    jumps: array_like, optional</span>
<span class="sd">       whether there are any jumps for the k-points that should not be taken into account</span>
<span class="sd">    jump_dk: float or array_like, optional</span>
<span class="sd">       how much total distance the jump points will take</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">BrillouinZone</span><span class="p">):</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">bz</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">bz</span>
    <span class="c1"># calculate vectors between each neighbouring points</span>
    <span class="n">dcart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cart</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">cart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># calculate distances</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcart</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="c1"># calculate the total distance</span>
    <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">jumps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Zero out the jumps</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">jumps</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># correct jumps</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">jumps</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_dist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jump_dk</span><span class="p">)</span>

    <span class="c1"># convert to linear scale</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">stop</span>
    <span class="c1"># Scale to total length of `stop`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_dist</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BrillouinZone</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; A class to construct Brillouin zone related quantities</span>

<span class="sd">    It takes any object (which has access to cell-vectors) as an argument</span>
<span class="sd">    and can then return the k-points in non-reduced units from reduced units.</span>

<span class="sd">    The object associated with the BrillouinZone object *has* to implement</span>
<span class="sd">    at least two different properties:</span>

<span class="sd">    1. `cell` which is the lattice vector</span>
<span class="sd">    2. `rcell` which is the reciprocal lattice vectors.</span>

<span class="sd">    The object may also be an array of floats in which case an internal</span>
<span class="sd">    `SuperCell` object will be created from the cell vectors (see `SuperCell` for</span>
<span class="sd">    details).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated ``parent.cell`` and ``parent.rcell`` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    k : array_like, optional</span>
<span class="sd">       k-points that this Brillouin zone represents</span>
<span class="sd">    weight : array_like, optional</span>
<span class="sd">       weights for the k-points. Must have the same length as `k`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BrillouinZone.__init__"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="c1"># Gamma point</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.__init__ requires input k-points and weights to be of equal length.&#39;</span><span class="p">)</span>

        <span class="c1"># Instantiate the array call</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span></div>

    <span class="n">apply</span> <span class="o">=</span> <span class="n">BrillouinZoneDispatcher</span><span class="p">(</span><span class="s2">&quot;apply&quot;</span><span class="p">,</span>
                                    <span class="c1"># Do not allow class dispatching</span>
                                    <span class="n">type_dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">obj_getattr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

<div class="viewcode-block" id="BrillouinZone.set_parent"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.set_parent">[docs]</a>    <span class="k">def</span> <span class="nf">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update the parent associated to this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : object or array_like</span>
<span class="sd">           an object containing cell vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># It probably has the supercell attached</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">cell</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;parent_class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span>
            <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset state of the object &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;parent_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;parent_class&#39;</span><span class="p">])</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;parent&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; String representation of the BrillouinZone &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{nk: </span><span class="si">{}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;{{nk: </span><span class="si">{}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">))</span>

<div class="viewcode-block" id="BrillouinZone.volume"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.volume">[docs]</a>    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the volume of the full Brillouin zone of the parent</span>

<span class="sd">        This will return the volume depending on the dimensions of the system.</span>
<span class="sd">        Here the dimensions of the system is determined by how many dimensions</span>
<span class="sd">        have auxilliary supercells that can contribute to Brillouin zone integrals.</span>
<span class="sd">        Therefore the returned value will have differing units depending on</span>
<span class="sd">        dimensionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ret_dim: bool, optional</span>
<span class="sd">           also return the dimensionality of the system</span>
<span class="sd">        periodic : array_like of int, optional</span>
<span class="sd">           estimate the volume using only the directions indexed by this array.</span>
<span class="sd">           The default value is `(self.parent.nsc &gt; 1).nonzero()[0]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol :</span>
<span class="sd">           the volume of the Brillouin zone. Units are Ang^D with D being the dimensionality.</span>
<span class="sd">           For 0D it will return 0.</span>
<span class="sd">        dimensionality : int</span>
<span class="sd">           the dimensionality of the volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># default periodic array</span>
        <span class="k">if</span> <span class="n">periodic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">volume</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="o">*</span><span class="n">periodic</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">length</span><span class="p">[</span><span class="n">periodic</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">ret_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vol</span><span class="p">,</span> <span class="n">dim</span>
        <span class="k">return</span> <span class="n">vol</span></div>

<div class="viewcode-block" id="BrillouinZone.parametrize"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.parametrize">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parametrize</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate a new `BrillouinZone` object with k-points parameterized via the function `func` in `N` separations</span>

<span class="sd">        Generator of a parameterized Brillouin zone object that contains a parameterized k-point</span>
<span class="sd">        list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : SuperCell, or SuperCellChild</span>
<span class="sd">           the object that the returned object will contain as parent</span>
<span class="sd">        func : callable</span>
<span class="sd">           method that parameterizes the k-points, *must* at least accept three arguments,</span>
<span class="sd">           1. ``parent``: object</span>
<span class="sd">           2. ``N``: total number of k-points</span>
<span class="sd">           3. ``i``: current index of the k-point (starting from 0)</span>

<span class="sd">           the function must return a k-point in 3 dimensions.</span>
<span class="sd">        N : int or list of int</span>
<span class="sd">           number of k-points generated using the parameterization,</span>
<span class="sd">           or a list of integers that will be looped over.</span>
<span class="sd">           In this case arguments ``N`` and ``i`` in `func` will be</span>
<span class="sd">           lists accordingly.</span>
<span class="sd">        *args :</span>
<span class="sd">           additional arguments passed directly to `func`</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           additional keyword arguments passed directly to `func`</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Simple linear k-points</span>

<span class="sd">        &gt;&gt;&gt; def func(sc, N, i):</span>
<span class="sd">        ...    return [i/N, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.parametrize(1, func, 10)</span>
<span class="sd">        &gt;&gt;&gt; assert len(bz) == 10</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(bz.k[-1, :], [9./10, 0, 0])</span>

<span class="sd">        For double looping, say to create your own grid</span>

<span class="sd">        &gt;&gt;&gt; def func(sc, N, i):</span>
<span class="sd">        ...    return [i[0]/N[0], i[1]/N[1], 0]</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.parametrize(1, func, [10, 5])</span>
<span class="sd">        &gt;&gt;&gt; assert len(bz) == 50</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># N must be some-kind of list like thingy</span>
            <span class="n">Nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nk</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">N</span><span class="p">))):</span>
                <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.param_circle"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.param_circle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">param_circle</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">N_or_dk</span><span class="p">,</span> <span class="n">kR</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a parameterized k-point list where the k-points are generated on a circle around an origin</span>

<span class="sd">        The generated circle is a perfect circle in the reciprocal space (Cartesian coordinates).</span>
<span class="sd">        To generate a perfect circle in units of the reciprocal lattice vectors one can</span>
<span class="sd">        generate the circle for a diagonal supercell with side-length :math:`2\pi`, see</span>
<span class="sd">        example below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : SuperCell, or SuperCellChild</span>
<span class="sd">           the parent object</span>
<span class="sd">        N_or_dk : int</span>
<span class="sd">           number of k-points generated using the parameterization (if an integer),</span>
<span class="sd">           otherwise it specifies the discretization length on the circle (in 1/Ang),</span>
<span class="sd">           If the latter case will use less than 4 points a warning will be raised and</span>
<span class="sd">           the number of points increased to 4.</span>
<span class="sd">        kR : float</span>
<span class="sd">           radius of the k-point. In 1/Ang</span>
<span class="sd">        normal : array_like of float</span>
<span class="sd">           normal vector to determine the circle plane</span>
<span class="sd">        origin : array_like of float</span>
<span class="sd">           origin of the circle used to generate the circular parameterization</span>
<span class="sd">        loop : bool, optional</span>
<span class="sd">           whether the first and last point are equal</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(sc, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>

<span class="sd">        To generate a circular set of k-points in reduced coordinates (reciprocal</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(sc, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz_rec = BrillouinZone.param_circle(2*np.pi, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz.k[:, :] = bz_rec.k[:, :]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BrillouinZone</span>
<span class="sd">            with the parameterized k-points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_or_dk</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N_or_dk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the required number of points</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kR</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N_or_dk</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="n">info</span><span class="p">(</span><span class="s1">&#39;BrillouinZone.param_circle increased the number of circle points to 4.&#39;</span><span class="p">)</span>

        <span class="c1"># Conversion object</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="n">normal</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="n">k_n</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">k_o</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Generate a preset list of k-points on the unit-circle</span>
        <span class="k">if</span> <span class="n">loop</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Now generate the rotation</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">k_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">k_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pv</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k_n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k_n</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate k-points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">*=</span> <span class="n">kR</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">toreduced</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">k_o</span><span class="p">)</span>

        <span class="c1"># The sum of weights is equal to the BZ area</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">kR</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">W</span> <span class="o">/</span> <span class="n">N</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.copy"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of this object, optionally changing the parent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : optional</span>
<span class="sd">           change the parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bz</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A list of all k-points (if available) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Weight of the k-points in the `BrillouinZone` object &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">cell</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rcell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>

<div class="viewcode-block" id="BrillouinZone.tocartesian"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.tocartesian">[docs]</a>    <span class="k">def</span> <span class="nf">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transfer a k-point in reduced coordinates to the Cartesian coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : list of float</span>
<span class="sd">           k-point in reduced coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            in units of 1/Ang</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcell</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.toreduced"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.toreduced">[docs]</a>    <span class="k">def</span> <span class="nf">toreduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Transfer a k-point in Cartesian coordinates to the reduced coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : list of float</span>
<span class="sd">           k-point in Cartesian coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            in units of reciprocal lattice vectors ]-0.5 ; 0.5] (if k is in the primitive cell)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span></div>

<div class="viewcode-block" id="BrillouinZone.in_primitive"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.in_primitive">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Move the k-point into the primitive point(s) ]-0.5 ; 0.5]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point(s) to move into the primitive cell</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            all k-points moved into the primitive cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.</span>

        <span class="c1"># Ensure that we are in the interval ]-0.5; 0.5]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span> <span class="o">-=</span> <span class="mf">1.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span> <span class="o">+=</span> <span class="mf">1.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">k</span></div>

    <span class="c1">#@deprecate_method TODO</span>
    <span class="n">_bz_attr</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#@deprecate_method TODO</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span> <span class="o">=</span> <span class="n">attr</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; does not exist in class &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">attr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="c1">#@deprecate_method TODO</span>
    <span class="k">def</span> <span class="nf">_bz_get_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal method to retrieve the actual function to be called &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.call"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.call">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.call is deprecated (&gt;0.9.9), register a BrillouinZoneParentDispatch to BrillouinZone.dispatch&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Call the function `func` and run as though the function has been called</span>

<span class="sd">        This is a wrapper to call user-defined functions not attached to the parent</span>
<span class="sd">        object.</span>

<span class="sd">        The below example shows that the equivalence of the call.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">        &gt;&gt;&gt; bz.eigh() == bz.call(H.eigh)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">           method used</span>
<span class="sd">        *args :</span>
<span class="sd">           arguments passed to func in the call sequence</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           keyword arguments passed to func in the call sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># Implement wrapper calls</span>
<div class="viewcode-block" id="BrillouinZone.asarray"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.asarray">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.asarray is deprecated (&gt;0.9.9), use BrillouinZone.apply.average&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with `numpy.ndarray` returned quantities</span>

<span class="sd">        This forces the `__call__` routine to return a single array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.array`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.asarray().eigh(eta=True)</span>

<span class="sd">        To compute multiple things in one go one should use wrappers to contain</span>
<span class="sd">        the calculation</span>

<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; dist = get_distribution(&#39;gaussian&#39;, smearing=0.1)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es, parent, k, weight):</span>
<span class="sd">        ...    DOS = es.DOS(E, distribution=dist)</span>
<span class="sd">        ...    PDOS = es.PDOS(E, distribution=dist)</span>
<span class="sd">        ...    occ = es.occupation()</span>
<span class="sd">        ...    spin_moment = (es.spin_moment(E, distribution=dist) * occ.reshape(-1, 1)).sum(0)</span>
<span class="sd">        ...    return oplist([DOS, PDOS, spin_moment])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS, spin_moment = bz.asarray().eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asarray&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">del</span> <span class="n">v</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># Set instance __bz_call</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asnone"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.asnone">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.asnone is deprecated (&gt;0.9.9), use BrillouinZone.apply.none&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asnone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with None, this may be done for instance when wrapping the function calls.</span>

<span class="sd">        This forces the `__call__` routine to return ``None``. This usage is mainly intended when</span>
<span class="sd">        creating custom `wrap` function calls.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.none`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.asnone().eigh(eta=True)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asnone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asnone&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asnone</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">if</span> <span class="n">_has_xarray</span><span class="p">:</span>
<div class="viewcode-block" id="BrillouinZone.asdataarray"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.asdataarray">[docs]</a>        <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.asdataarray is deprecated (&gt;0.9.9), use BrillouinZone.apply.dataarray&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">asdataarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return `self` with `xarray.DataArray` returned quantities</span>

<span class="sd">            This forces the `__call__` routine to return a single `xarray.DataArray`.</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            This method will be deprecated &gt;0.9.9.</span>
<span class="sd">            Please use ``self.apply.dataarray`` instead.</span>

<span class="sd">            If you wrap the sub-method to return multiple data-sets, you should use `asdataset`</span>
<span class="sd">            instead which returns a combination of data-arrays (so-called `xarray.Dataset`).</span>

<span class="sd">            All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">            eta : bool, optional</span>
<span class="sd">                if true a progress-bar is created, default false.</span>
<span class="sd">            wrap : callable, optional</span>
<span class="sd">                a function that accepts the output of the given routine and post-process</span>
<span class="sd">                it. Defaults to ``lambda x: x``.</span>
<span class="sd">            coords : list of str or list of (str, array), optional</span>
<span class="sd">                a list of coordinates used in ``xarray.DataArray(..., coords=coords)``.</span>
<span class="sd">                By default the coordinates are named ``[&#39;k&#39;, &#39;v1&#39;, &#39;v2&#39;, ...]``</span>
<span class="sd">                depending on the shape of the returned quantity.</span>
<span class="sd">                These may optionally be a list of tuples (not a dictionary)!</span>

<span class="sd">            Examples</span>
<span class="sd">            --------</span>
<span class="sd">            &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">            &gt;&gt;&gt; obj.asdataarray().eigh(eta=True)</span>

<span class="sd">            See Also</span>
<span class="sd">            --------</span>
<span class="sd">            asyield : all output returned through an iterator</span>
<span class="sd">            asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">            assum : return the sum of values in the Brillouin zone</span>
<span class="sd">            aslist : all output returned as a Python list</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">asdataarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>

                <span class="c1"># xarray specific data (default to function name)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
                <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                    <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asarray&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
                <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">)</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">del</span> <span class="n">v</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Create coords</span>
                <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                            <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bz&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span>
                         <span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">)</span>

            <span class="c1"># Set instance __bz_call</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asdataarray</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.aslist"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.aslist">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.aslist is deprecated (&gt;0.9.9), use BrillouinZone.apply.list&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">aslist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with `list` returned quantities</span>

<span class="sd">        This forces the `__call__` routine to return a list with returned values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.list`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(...)</span>
<span class="sd">        &gt;&gt;&gt; def first_ten(es):</span>
<span class="sd">        ...    return es.sub(range(10))</span>
<span class="sd">        &gt;&gt;&gt; obj.aslist().eigenstate(eta=True, wrap=first_ten)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">aslist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.aslist&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">aslist</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asyield"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.asyield">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.asyield is deprecated (&gt;0.9.9), use BrillouinZone.apply.iter&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asyield</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with yielded quantities</span>

<span class="sd">        This forces the `__call__` routine to return a an iterator which may</span>
<span class="sd">        yield the quantities calculated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.iter`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asyield().eigh(eta=True)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asyield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asyield&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asyield</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.asaverage"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.asaverage">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.asaverage is deprecated (&gt;0.9.9), use BrillouinZone.apply.average&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asaverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with k-averaged quantities</span>

<span class="sd">        This forces the `__call__` routine to return a single k-averaged value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.average`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage().DOS(np.linspace(-2, 2, 100))</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage()</span>
<span class="sd">        &gt;&gt;&gt; obj.DOS(np.linspace(-2, 2, 100))</span>
<span class="sd">        &gt;&gt;&gt; obj.PDOS(np.linspace(-2, 2, 100), eta=True)</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.asaverage()</span>
<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es):</span>
<span class="sd">        ...    return es.DOS(E), es.PDOS(E)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS = obj.eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        assum : return the sum of values in the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asaverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asaverage&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asaverage</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.assum"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.assum">[docs]</a>    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="s2">&quot;BrillouinZone.assum is deprecated (&gt;0.9.9), use BrillouinZone.apply.sum&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">assum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with summed quantities</span>

<span class="sd">        This forces the `__call__` routine to return all k-point values summed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method will be deprecated &gt;0.9.9.</span>
<span class="sd">        Please use ``self.apply.sum`` instead.</span>

<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.assum().DOS(np.linspace(-2, 2, 100))</span>

<span class="sd">        &gt;&gt;&gt; obj = BrillouinZone(Hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; obj.assum()</span>
<span class="sd">        &gt;&gt;&gt; obj.DOS(np.linspace(-2, 2, 100))</span>
<span class="sd">        &gt;&gt;&gt; obj.PDOS(np.linspace(-2, 2, 100), eta=True)</span>

<span class="sd">        &gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; dist = get_distribution(&#39;gaussian&#39;, smearing=0.1)</span>
<span class="sd">        &gt;&gt;&gt; def wrap(es, parent, k, weight):</span>
<span class="sd">        ...    DOS = es.DOS(E, distribution=dist) * weight</span>
<span class="sd">        ...    PDOS = es.PDOS(E, distribution=dist) * weight</span>
<span class="sd">        ...    occ = es.occupation()</span>
<span class="sd">        ...    spin_moment = (es.spin_moment(E, distribution=dist) * occ.reshape(-1, 1)).sum(0) * weight</span>
<span class="sd">        ...    return oplist([DOS, PDOS, spin_moment])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone(hamiltonian)</span>
<span class="sd">        &gt;&gt;&gt; DOS, PDOS, spin_moment = bz.assum().eigenstate(wrap=wrap)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">assum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">has_wrap</span> <span class="o">=</span> <span class="s1">&#39;wrap&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.assum&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
            <span class="k">if</span> <span class="n">has_wrap</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">oplist</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">oplist</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">v</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">assum</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="BrillouinZone.__call__"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls the given attribute of the internal object and returns the quantity</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : optional</span>
<span class="sd">            arguments passed to the attribute call, note that an argument `k=k` will be</span>
<span class="sd">            added by this routine as a way to loop the k-points.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            keyword arguments passed to the attribute call, note that the first argument</span>
<span class="sd">            will *always* be `k`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        *</span>
<span class="sd">            whatever ``getattr(self, attr)(k, *args, **kwargs)`` returns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">call</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">)</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">call</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">method2</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fmt</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;as&quot;</span><span class="p">):</span>
                <span class="n">fmt</span><span class="p">[</span><span class="s2">&quot;method2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>

            <span class="n">deprecate</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{method}{func}</span><span class="s2">(...) is deprecated (&gt;0.9.9), &quot;</span>
                      <span class="s2">&quot;please use </span><span class="si">{cls}</span><span class="s2">.apply.</span><span class="si">{method2}{func}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">fmt</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Could not call the object it self&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BrillouinZone.iter"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; An iterator for the k-points and (possibly) the weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ret_weight : bool, optional</span>
<span class="sd">          if true, also yield the weight for the respective k-point</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        kpt : k-point</span>
<span class="sd">        weight : weight of k-point, only if `ret_weight` is true.</span>
<span class="sd">       &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ret_weight</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span></div>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.write"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes k-points to a `~sisl.io.tableSile`.</span>

<span class="sd">        This allows one to pass a `tableSile` or a file-name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">tableSile</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">tableSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">tableSile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MonkhorstPack</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a Monkhorst-Pack grid for the Brillouin zone</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parent.cell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    nkpt : array_like of ints</span>
<span class="sd">       a list of number of k-points along each cell direction</span>
<span class="sd">    displacement : float or array_like of float, optional</span>
<span class="sd">       the displacement of the evenly spaced grid, a single floating</span>
<span class="sd">       number is the displacement for the 3 directions, else they</span>
<span class="sd">       are the individual displacements</span>
<span class="sd">    size : float or array_like of float, optional</span>
<span class="sd">       the size of the Brillouin zone sampled. This reduces the boundaries</span>
<span class="sd">       of the Brillouin zone around the displacement to the fraction specified.</span>
<span class="sd">       I.e. `size` must be of values :math:`]0 ; 1]`. Defaults to the entire BZ.</span>
<span class="sd">       Note that this will also reduce the weights such that the weights</span>
<span class="sd">       are normalized to the entire BZ.</span>
<span class="sd">    centered : bool, optional</span>
<span class="sd">       whether the k-points are :math:`\Gamma`-centered (for zero displacement)</span>
<span class="sd">    trs : bool, optional</span>
<span class="sd">       whether time-reversal symmetry exists in the Brillouin zone.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell(3.)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, 10) # 10 x 10 x 10 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, [10, 5, 5]) # 10 x 5 x 5 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(sc, [10, 5, 5], trs=False) # 10 x 5 x 5 (without TRS)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MonkhorstPack.__init__"><a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">displacement</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">nkpt</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span>

        <span class="c1"># Now we have a matrix of k-points</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nkpt</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; with off-diagonal components is not implemented yet&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">displacement</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Retrieve the diagonal number of values</span>
        <span class="n">Dn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> *must* be initialized with &#39;</span>
                             <span class="s1">&#39;diagonal elements different from 0.&#39;</span><span class="p">)</span>

        <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">trs</span><span class="p">:</span>
            <span class="c1"># Figure out which direction to TRS</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span> <span class="ow">and</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
                    <span class="n">nmax</span> <span class="o">=</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i_trs</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">nmax</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">i_trs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If we still haven&#39;t decided (say for weird displacements)</span>
                <span class="c1"># simply take the one with the maximum number of k-points.</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span>

        <span class="c1"># Calculate k-points and weights along all directions</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">centered</span><span class="p">,</span> <span class="n">i</span> <span class="o">==</span> <span class="n">i_trs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Now figure out if we have a 0 point along the TRS direction</span>
        <span class="k">if</span> <span class="n">trs</span><span class="p">:</span>
            <span class="c1"># Figure out if the first value is zero</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="n">i_trs</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="c1"># Find indices we want to delete</span>
                <span class="n">ik1</span><span class="p">,</span> <span class="n">ik2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_trs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i_trs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
                <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">k_dup</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">k_dup</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Figure out the duplicate values</span>
                <span class="c1"># To do this we calculate the norm matrix</span>
                <span class="c1"># Note for a 100 x 100 k-point sampling this will produce</span>
                <span class="c1"># a 100 ^ 4 matrix ~ 93 MB</span>
                <span class="c1"># For larger k-point samplings this is probably not so good (300x300 -&gt; 7.5 GB)</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="n">k_dup</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">k_dup</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="p">((</span><span class="n">k_dup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k_dup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="c1"># At this point we have found all duplicate points, to only take one</span>
                <span class="c1"># half of the points we only take the lower half</span>
                <span class="c1"># Also, the Gamma point is *always* zero, so we shouldn&#39;t do &lt;=!</span>
                <span class="c1"># Now check the case where one of the directions is (only) the Gamma-point</span>
                <span class="k">if</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                    <span class="c1"># We keep all indices for the ik1 direction (since it is the Gamma-point!</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                    <span class="c1"># We keep all indices for the ik2 direction (since it is the Gamma-point!</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">rel</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">rel</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># To signal we can&#39;t do this</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">((</span><span class="n">kw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">kw</span>
        <span class="c1"># Now clean up a few of the points</span>
        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">k_dup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create the correct indices in the ravelled indices</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">k_del</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k_dup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">k</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">k_dup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">k_del</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="n">k_dup</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="n">k_del</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">k_del</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">k_dup</span><span class="p">,</span> <span class="n">k_del</span>

        <span class="c1"># Store information regarding size and diagonal elements</span>
        <span class="c1"># This information is basically only necessary when</span>
        <span class="c1"># we want to replace special k-points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span> <span class="o">=</span> <span class="n">Dn</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">=</span> <span class="n">displacement</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span> <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span> <span class="o">=</span> <span class="n">centered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">=</span> <span class="n">i_trs</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; String representation of MonkhorstPack &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">sc</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{cls}</span><span class="s1">{{nk: </span><span class="si">{nk:d}</span><span class="s1">, size: [</span><span class="si">{size[0]:.3f}</span><span class="s1"> </span><span class="si">{size[1]:.3f}</span><span class="s1"> </span><span class="si">{size[0]:.3f}</span><span class="s1">], trs: </span><span class="si">{trs}</span><span class="s1">,&#39;</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> diagonal: [</span><span class="si">{diag[0]:d}</span><span class="s1"> </span><span class="si">{diag[1]:d}</span><span class="s1"> </span><span class="si">{diag[2]:d}</span><span class="s1">], displacement: [</span><span class="si">{disp[0]:.3f}</span><span class="s1"> </span><span class="si">{disp[1]:.3f}</span><span class="s1"> </span><span class="si">{disp[2]:.3f}</span><span class="s1">],&#39;</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> </span><span class="si">{sc}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">nk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                      <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trs</span><span class="p">,</span> <span class="s1">&#39;no&#39;</span><span class="p">),</span>
                                      <span class="n">diag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;diag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;displ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;centered&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;trs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset state of the object &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;diag&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;displ&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;centered&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;trs&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="MonkhorstPack.copy"><a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of this object, optionally changing the parent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : optional</span>
<span class="sd">           change the parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bz</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">bz</span></div>

<div class="viewcode-block" id="MonkhorstPack.asgrid"><a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.asgrid">[docs]</a>    <span class="k">def</span> <span class="nf">asgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return `self` with Grid quantities</span>

<span class="sd">        This forces the `__call__` routine to return all k-point values in a regular grid.</span>

<span class="sd">        The calculation of values on a grid requires some careful thought before</span>
<span class="sd">        running the calculation as the returned grid may be somewhat difficult</span>
<span class="sd">        to comprehend.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All invocations of sub-methods are added these keyword-only arguments:</span>

<span class="sd">        eta : bool, optional</span>
<span class="sd">           if true a progress-bar is created, default false.</span>
<span class="sd">        wrap : callable, optional</span>
<span class="sd">           a function that accepts the output of the given routine and post-process</span>
<span class="sd">           it. Defaults to ``lambda x: x``.</span>
<span class="sd">        data_axis : int, optional</span>
<span class="sd">           the Grid axis to put in the data values in. Has to be specified if the</span>
<span class="sd">           subsequent routine calls return more than 1 data-point per k-point.</span>
<span class="sd">        grid_unit : {&#39;b&#39;, &#39;Ang&#39;, &#39;Bohr&#39;}, optional</span>
<span class="sd">           for &#39;b&#39; the returned grid will be a cube, otherwise the grid will be the reciprocal lattice</span>
<span class="sd">           vectors (for any other value) and in the given reciprocal unit (&#39;Ang&#39; =&gt; 1/Ang)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; obj = MonkhorstPack(Hamiltonian, [10, 1, 10])</span>
<span class="sd">        &gt;&gt;&gt; grid = obj.asgrid().eigh(data_axis=1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        asarray : all output as a single array</span>
<span class="sd">        asyield : all output returned through an iterator</span>
<span class="sd">        asaverage : take the average (with k-weights) of the Brillouin zone</span>
<span class="sd">        aslist : all output returned as a Python list</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">asgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">data_axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;data_axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">grid_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>

            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bz_get_func</span><span class="p">()</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">allow_kwargs</span><span class="p">(</span><span class="s1">&#39;parent&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.asgrid&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>

            <span class="c1"># Extract information from the MP grid, these values</span>
            <span class="c1"># define the Grid size, etc.</span>
            <span class="n">diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="si">}</span><span class="s1"> requires the displacement to be 0 for all k-points.&#39;</span><span class="p">)</span>
            <span class="n">displ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">steps</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">diag</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">steps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">steps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>

            <span class="c1"># Instead of doing</span>
            <span class="c1">#    _in_primitive(k) + 0.5 - offset</span>
            <span class="c1"># we can do it here</span>
            <span class="c1">#    _in_primitive(k) + offset&#39;</span>
            <span class="n">offset</span> <span class="o">-=</span> <span class="mf">0.5</span>

            <span class="c1"># Check the TRS direction</span>
            <span class="n">trs_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span>
            <span class="n">_in_primitive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span>
            <span class="n">_rint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span>
            <span class="n">_int32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
            <span class="k">def</span> <span class="nf">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="c1"># In case TRS is applied two indices may be returned</span>
                <span class="k">return</span> <span class="n">_rint</span><span class="p">((</span><span class="n">_in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">steps</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_int32</span><span class="p">)</span>
                <span class="c1"># To find the opposite k-point, do this</span>
                <span class="c1">#  idx[i] = [diag[i] - idx[i] - 1, idx[i]</span>
                <span class="c1"># with i in [0, 1, 2]</span>

            <span class="c1"># Create cell from the reciprocal cell.</span>
            <span class="k">if</span> <span class="n">grid_unit</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">rcell</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">units</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">,</span> <span class="n">grid_unit</span><span class="p">)</span>

            <span class="c1"># Find the grid origin</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">cell</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Calculate first k-point (to get size and dtype)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span><span class="si">}</span><span class="s1"> requires one value per-kpoint because of the 3D grid values&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Check the weights</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">diag</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span> <span class="n">displ</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">data_axis</span><span class="p">],</span>
                                    <span class="n">centered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="n">trs_axis</span> <span class="o">==</span> <span class="n">data_axis</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Correct the Grid size</span>
                <span class="n">diag</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># Create the orthogonal cell direction to ensure it is orthogonal</span>
                <span class="c1"># Since array axis is cyclic for negative numbers, we simply do this</span>
                <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
                <span class="c1"># Check whether we should rotate it</span>
                <span class="k">if</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">cell</span><span class="p">[</span><span class="n">data_axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Correct cell for the grid</span>
            <span class="k">if</span> <span class="n">trs_axis</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">origin</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="c1"># Correct offset since we only have the positive halve</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">:</span>
                    <span class="n">offset</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">offset</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

                <span class="c1"># Find number of points</span>
                <span class="k">if</span> <span class="n">trs_axis</span> <span class="o">!=</span> <span class="n">data_axis</span><span class="p">:</span>
                    <span class="n">diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">diag</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span> <span class="n">displ</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">trs_axis</span><span class="p">],</span>
                                                   <span class="n">centered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_centered</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Create the grid in the reciprocal cell</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]]</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">grid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">weight</span>

            <span class="k">del</span> <span class="n">v</span>

            <span class="c1"># Now perform calculation</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">data_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                                             <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">k2idx</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]]</span>
                    <span class="n">idx</span><span class="p">[</span><span class="n">data_axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">grid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
                                            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">weight</span>
                    <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">grid</span>

        <span class="c1"># Set instance __call__</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_bz_call&#39;</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">asgrid</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MonkhorstPack.grid"><a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.grid">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">displ</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a grid of `n` points with an offset of `displ` and sampling `size` around `displ`</span>

<span class="sd">        The :math:`k`-points are :math:`\Gamma` centered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">           number of points in the grid. If `trs` is ``True`` this may be smaller than `n`</span>
<span class="sd">        displ : float, optional</span>
<span class="sd">           the displacement of the grid</span>
<span class="sd">        size : float, optional</span>
<span class="sd">           the total size of the Brillouin zone to sample</span>
<span class="sd">        centered : bool, optional</span>
<span class="sd">           if the points are centered</span>
<span class="sd">        trs : bool, optional</span>
<span class="sd">           whether time-reversal-symmetry is applied</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : numpy.ndarray</span>
<span class="sd">           the list of k-points in the Brillouin zone to be sampled</span>
<span class="sd">        w : numpy.ndarray</span>
<span class="sd">           weights for the k-points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First ensure that displ is in the Brillouin</span>
        <span class="n">displ</span> <span class="o">=</span> <span class="n">displ</span> <span class="o">%</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">-=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">+=</span> <span class="mf">1.</span>

        <span class="c1"># Centered _only_ has effect IFF</span>
        <span class="c1">#  displ == 0. and size == 1</span>
        <span class="c1"># Otherwise we resort to other schemes</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
            <span class="n">centered</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># We create the full grid, then afterwards we figure out TRS</span>
        <span class="n">n_half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="n">displ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span> <span class="o">+</span> <span class="n">displ</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">:</span>
                <span class="c1"># Shift everything by halve the size each occupies</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Move k to the primitive cell and generate weights</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>

        <span class="c1"># Check for TRS points</span>
        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="c1"># Make all positive to remove the double conting terms</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># Sort k-points and weights</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span>

            <span class="c1"># Re-arange according to k value</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">k_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># Find indices of all equivalent k-points (tolerance of 1e-10 in reciprocal units)</span>
            <span class="c1">#  1e-10 ~ 1e10 k-points (no body will do this!)</span>
            <span class="n">idx_same</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The above algorithm should never create more than two duplicates.</span>
            <span class="c1"># Hence we can simply remove all idx_same and double the weight for all</span>
            <span class="c1"># idx_same + 1.</span>
            <span class="n">w</span><span class="p">[</span><span class="n">idx_same</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="c1"># Delete the duplicated k-points (they are already sorted)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k_pos</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sort them, because it makes more visual sense</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Return values</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span></div>

<div class="viewcode-block" id="MonkhorstPack.replace"><a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Replace a k-point with a new set of k-points from a Monkhorst-Pack grid</span>

<span class="sd">        This method tries to replace an area corresponding to `mp.size` around the k-point `k`</span>
<span class="sd">        such that the k-points are replaced.</span>
<span class="sd">        This enables one to zoom in on specific points in the Brillouin zone for detailed analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point in this object to replace</span>
<span class="sd">        mp : MonkhorstPack</span>
<span class="sd">           object containing the replacement k-points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 3x3x3 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [3, 3, 3], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x4 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [4, 4, 4], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x1 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; sc = SuperCell(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(sc, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(sc, [4, 4, 1], size=1./3))</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislError</span>
<span class="sd">            if the size of the replacement `MonkhorstPack` grid is not compatible with the k-point spacing in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we find all k-points within k +- mp.size</span>
        <span class="c1"># Those are the points we wish to remove.</span>
        <span class="c1"># Secondly we need to ensure that the k-points we remove are occupying *exactly*</span>
        <span class="c1"># the Brillouin zone we wish to replace.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">MonkhorstPack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Object `mp` is not a MonkhorstPack object&#39;</span><span class="p">)</span>

        <span class="c1"># We can easily figure out the BZ that each k-point is averaging</span>
        <span class="n">k_vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span>
        <span class="c1"># Compare against the size of this one</span>
        <span class="c1"># Since we can remove more than one k-point, we require that the</span>
        <span class="c1"># size of the replacement MP is an integer multiple of the</span>
        <span class="c1"># k-point volumes.</span>
        <span class="n">k_int</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="n">k_vol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">k_int</span><span class="p">),</span> <span class="n">k_int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.reduce could not replace k-point, BZ &#39;</span>
                            <span class="s1">&#39;volume replaced is not equivalent to the inherent k-point volume.&#39;</span><span class="p">)</span>
        <span class="n">k_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">k_int</span><span class="p">)</span>

        <span class="c1"># 1. find all k-points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Find all points within [k - dk; k + dk]</span>
        <span class="c1"># Since the volume of each k-point is non-zero we know that no k-points will be located</span>
        <span class="c1"># on the boundary.</span>
        <span class="c1"># This does remove boundary points because we shift everything into the positive</span>
        <span class="c1"># plane.</span>
        <span class="n">diff_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">k</span> <span class="o">%</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_k</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.reduce could not find any points to replace.&#39;</span><span class="p">)</span>

        <span class="c1"># Now we have the k-points we need to remove</span>
        <span class="c1"># Figure out if the total weight is consistent</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">replace_weight</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">2.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.reduce assumes that the replaced k-point has double weights.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-point to replace:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;delta-k:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">dk</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found k-indices that will be replaced:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;k-points replaced:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.reduce could not assert the weights are consistent during replacement.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Append the new k-points and weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">_k</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">_w</span> <span class="o">*</span> <span class="n">weight_factor</span><span class="p">))</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BandStructure</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Create a path in the Brillouin zone for plotting band-structures etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parent.cell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `SuperCell`</span>
<span class="sd">    points : array_like of float</span>
<span class="sd">       a list of points that are the *corners* of the path</span>
<span class="sd">    divisions : int or array_like of int</span>
<span class="sd">       number of divisions in each segment.</span>
<span class="sd">       If a single integer is passed it is the total number</span>
<span class="sd">       of points on the path (equally separated).</span>
<span class="sd">       If it is an array_like input it must have length one</span>
<span class="sd">       less than `point`, in this case the total number of points</span>
<span class="sd">       will be ``sum(divisions) + 1`` due to the end-point constraint.</span>
<span class="sd">    names : array_like of str</span>
<span class="sd">       the associated names of the points on the Brillouin Zone path</span>
<span class="sd">    jump_dk: float or array_like, optional</span>
<span class="sd">       Percentage of ``self.lineark()[-1]`` that is used as separation between discontinued</span>
<span class="sd">       jumps in the band-structure.</span>
<span class="sd">       For band-structures with disconnected jumps the `lineark` and `lineartick` methods</span>
<span class="sd">       returns a separation between the disconnected points according to this percentage.</span>
<span class="sd">       Default value is 5% of the total distance. Alternatively an array equal to the</span>
<span class="sd">       number of discontinuity jumps may be passed for individual percentages.</span>
<span class="sd">       Keyword only, argument.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell(10)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3, [1.] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0] * 3, [0.5] * 3, [1.] * 3], 200, [&#39;Gamma&#39;, &#39;M&#39;, &#39;Gamma&#39;])</span>

<span class="sd">    A disconnected band structure may be created by either having a point of 0 length, or None.</span>
<span class="sd">    Note that the number of names does not contain the empty points (they are simply removed).</span>
<span class="sd">    Such a band-structure may be useful when one is not interested in a fully connected band structure.</span>

<span class="sd">    &gt;&gt;&gt; bs = BandStructure(sc, [[0, 0, 0], [0, 0.5, 0], None, [0.5, 0, 0], [0.5, 0.5, 0]], 200)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BandStructure.__init__"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#points, divisions, names=None):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;point&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">deprecate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(point=) is deprecated, use (points=) instead&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;0.13.0&quot;</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;point&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &#39;points&#39; argument missing&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;division&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">deprecate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(division=) is deprecated, use (divisions=) instead&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;0.13.0&quot;</span><span class="p">)</span>
        <span class="n">divisions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;divisions&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;division&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">divisions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">divisions</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &#39;divisions&#39; argument missing&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">deprecate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(name=) is deprecated, use (names=) instead&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;0.13.0&quot;</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> unknown arguments after parsing &#39;points&#39;, &#39;divisions&#39; and &#39;names&#39;: </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Store empty split size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;jump_dk&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">))</span>

        <span class="c1"># Copy over points</span>
        <span class="c1"># Check if any of the points is None or has length 0</span>
        <span class="c1"># In that case it is a disconnected path</span>
        <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">ix</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="c1"># filter out jump directions</span>
        <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">is_empty</span><span class="p">,</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">))])</span>

        <span class="c1"># store only *valid* points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">jump_idx</span><span class="p">])</span>

        <span class="c1"># remove erroneous jumps</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">jump_idx</span><span class="p">:</span>
            <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">jump_idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">jump_idx</span><span class="p">:</span>
            <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">jump_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">jump_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> got inconsistent argument lengths (jump_dk does not match jumps in points)&quot;</span><span class="p">)</span>

        <span class="c1"># The jump-idx is equal to using np.split(self.points, jump_idx)</span>
        <span class="c1"># which then returns continuous sections</span>
        <span class="c1"># correct for removed indices</span>
        <span class="n">jump_idx</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">jump_idx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">=</span> <span class="n">jump_idx</span>

        <span class="c1"># If the array has fewer points we try and determine</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not determine the non-periodic direction&#39;</span><span class="p">)</span>

            <span class="c1"># fix the points where there are no periodicity</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Now figure out what to do with the divisions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divisions</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">divisions</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can not evenly split </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2"> points into </span><span class="si">{</span><span class="n">divisions</span><span class="si">}</span><span class="s2"> divisions, ensure division&gt;=len(points)&quot;</span><span class="p">)</span>

            <span class="c1"># Get length between different k-points with a total length</span>
            <span class="c1"># of division</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">linspace_bz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="n">jumps</span><span class="o">=</span><span class="n">jump_idx</span><span class="p">,</span> <span class="n">jump_dk</span><span class="o">=</span><span class="mf">0.</span><span class="p">))</span>

            <span class="c1"># Get floating point divisions</span>
            <span class="n">divs_r</span> <span class="o">=</span> <span class="n">dists</span> <span class="o">*</span> <span class="n">divisions</span> <span class="o">/</span> <span class="n">dists</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># Convert to integers</span>
            <span class="n">divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">divs_r</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="c1"># ensure at least 1 point along each division</span>
            <span class="c1"># 1 division means only the starting point</span>
            <span class="n">divs</span><span class="p">[</span><span class="n">divs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">divs</span><span class="p">[</span><span class="n">jump_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">divs_sum</span> <span class="o">=</span> <span class="n">divs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">divs_sum</span> <span class="o">!=</span> <span class="n">divisions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># only check indices where divs &gt; 1</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">divs_sum</span> <span class="o">&gt;=</span> <span class="n">divisions</span><span class="p">:</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dk</span><span class="p">)]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dk</span><span class="p">)]]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">divs_sum</span> <span class="o">=</span> <span class="n">divs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">divisions</span> <span class="o">=</span> <span class="n">divs</span><span class="p">[:]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inconsistent number of elements in &#39;points&#39; and &#39;divisions&#39; argument. One less &#39;divisions&#39; elements.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="s1">&#39;ABCDEFGHIJKLMNOPQRSTUVXYZ&#39;</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inconsistent number of elements in &#39;points&#39; and &#39;names&#39; argument&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate points</span>
        <span class="n">dpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="p">(</span><span class="n">divs</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">,</span> <span class="n">dpoint</span><span class="p">)):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">divs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">+</span> <span class="n">dk</span> <span class="o">*</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">divs</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">divs</span>
        <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># sanity check that should always be obeyed</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span></div>

<div class="viewcode-block" id="BandStructure.copy"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a copy of this object, optionally changing the parent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : optional</span>
<span class="sd">           change the parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">jump_dk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bz</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;divisions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;jump_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;jump_dk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset state of the object &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;divisions&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;jump_dk&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;jump_idx&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="BandStructure.insert_jump"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.insert_jump">[docs]</a>    <span class="k">def</span> <span class="nf">insert_jump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a copy of `arrays` filled with `value` at indices of discontinuity jumps</span>

<span class="sd">        Arrays with `value` in jumps is easier to plot since those lines will be naturally discontinued.</span>
<span class="sd">        For band structures without discontinuity jumps in the Brillouin zone the `arrays` will</span>
<span class="sd">        be return as is.</span>

<span class="sd">        It will insert `value` along the first dimension matching the length of `self`.</span>
<span class="sd">        For each discontinuity jump an element will be inserted.</span>

<span class="sd">        This may be useful for plotting since `np.nan` gets interpreted as a discontinuity</span>
<span class="sd">        in the graph thus removing connections between the segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *arrays : array_like</span>
<span class="sd">           arrays will get `value` inserted where there are jumps in the band structure</span>
<span class="sd">        value : optional</span>
<span class="sd">           the value to be inserted at the jump points in the data array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a bandrstructure with a discontinuity.</span>

<span class="sd">        &gt;&gt;&gt; gr = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; bs = BandStructure(gr, [[0, 0, 0], [0.5, 0, 0], None, [0, 0, 0], [0, 0.5, 0]], 4)</span>
<span class="sd">        &gt;&gt;&gt; data = np.zeros([len(bs), 10])</span>
<span class="sd">        &gt;&gt;&gt; data_with_jump = bs.insert_jump(data)</span>
<span class="sd">        &gt;&gt;&gt; assert data_with_jump.shape == (len(bs)+1, 10)</span>
<span class="sd">        &gt;&gt;&gt; np.all(data_with_jump[2] == np.nan)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># quick return if nothing needs changed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">arrays</span>

        <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">full_jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">_insert</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="c1"># ensure dtype is equivalent as input array</span>
            <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_jumps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">nans</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">full_jumps</span><span class="p">,</span> <span class="n">nans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># convert all</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_insert</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arrays</span></div>

<div class="viewcode-block" id="BandStructure.lineartick"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.lineartick">[docs]</a>    <span class="k">def</span> <span class="nf">lineartick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The tick-marks corresponding to the linear-k values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            the positions in reciprocal space determined by the distance between points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lineark : Routine used to calculate the tick-marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span></div>

<div class="viewcode-block" id="BandStructure.tolinear"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.tolinear">[docs]</a>    <span class="k">def</span> <span class="nf">tolinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ret_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert a k-point into the equivalent linear k-point via the distance</span>

<span class="sd">        Finds the index of the k-point in `self.k` that is closests to `k`.</span>
<span class="sd">        The returned value is then the equivalent index in `lineark`.</span>

<span class="sd">        This is very useful for extracting certain points along the band structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           the k-point(s) to locate in the linear values</span>
<span class="sd">        ret_index : bool, optional</span>
<span class="sd">           whether the indices are also returned</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">           when the found k-point has a distance (in Cartesian coordinates)</span>
<span class="sd">           is differing by more than `tol` a warning will be issued.</span>
<span class="sd">           The tolerance is in units 1/Ang.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Faster than to do sqrt all the time</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># first convert to the cartesian coordinates (for proper distances)</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># find closest values</span>
        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">kk</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.tolinear could not find a k-point within given tolerance (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">toreduced</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ret_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">()[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">idxs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">()[</span><span class="n">idxs</span><span class="p">]</span></div>

<div class="viewcode-block" id="BandStructure.lineark"><a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.lineark">[docs]</a>    <span class="k">def</span> <span class="nf">lineark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A 1D array which corresponds to the delta-k values of the path</span>

<span class="sd">        This is mainly meant for plotting but may be useful for finding out</span>
<span class="sd">        distances in the reciprocal lattice.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(p.lineark(), eigs[:, i])</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; lk, kt, kl = p.lineark(True)</span>
<span class="sd">        &gt;&gt;&gt; plt.xticks(kt, kl)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(lk, eigs[:, i])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ticks : bool, optional</span>
<span class="sd">           if `True` the ticks for the points are also returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        linspace_bz : converts k-points into a linear distance parameterization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linear_k : numpy.ndarray</span>
<span class="sd">            the positions in reciprocal space determined by the distance between points</span>
<span class="sd">        ticks : numpy.ndarray</span>
<span class="sd">            linear k-positions of the points, only returned if `ticks` is ``True``</span>
<span class="sd">        ticklabels : list of str</span>
<span class="sd">            labels at `ticks`, only returned if `ticks` is ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cum_divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">)</span>
        <span class="c1"># Calculate points</span>
        <span class="c1"># First we also need to calculate the jumps</span>
        <span class="n">dK</span> <span class="o">=</span> <span class="n">linspace_bz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jumps</span><span class="o">=</span><span class="n">cum_divs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">jump_dk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="p">)</span>

        <span class="c1"># Get label tick, in case self.names is a single string &#39;ABCD&#39;</span>
        <span class="k">if</span> <span class="n">ticks</span><span class="p">:</span>
            <span class="c1"># Get number of points</span>
            <span class="n">xtick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">xtick</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">cum_divs</span>
            <span class="c1"># Ensure the returned label_tick is a copy</span>
            <span class="k">return</span> <span class="n">dK</span><span class="p">,</span> <span class="n">dK</span><span class="p">[</span><span class="n">xtick</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dK</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2022, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>