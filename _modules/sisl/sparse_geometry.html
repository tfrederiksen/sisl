<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.sparse_geometry &mdash; sisl 0.1.dev1+ga8efd77 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> sisl
          </a>
              <div class="version">
                0.1.dev1+ga8efd77
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/scripts.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>sisl.sparse_geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.sparse_geometry</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">ftool</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.mixins</span> <span class="kn">import</span> <span class="n">NDArrayOperatorsMixin</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">int32</span><span class="p">,</span> <span class="n">intersect1d</span><span class="p">,</span>
    <span class="n">take</span><span class="p">,</span> <span class="n">delete</span><span class="p">,</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">lexsort</span><span class="p">,</span>
    <span class="n">insert</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">allclose</span><span class="p">,</span>
    <span class="n">searchsorted</span><span class="p">,</span>
    <span class="n">tile</span><span class="p">,</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">concatenate</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">._internal</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span> <span class="nn">._array</span> <span class="kn">import</span> <span class="n">array_arange</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">.orbital</span> <span class="kn">import</span> <span class="n">Orbital</span>
<span class="kn">from</span> <span class="nn">.geometry</span> <span class="kn">import</span> <span class="n">Geometry</span>
<span class="kn">from</span> <span class="nn">.messages</span> <span class="kn">import</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">,</span> <span class="n">progressbar</span><span class="p">,</span> <span class="n">deprecate_method</span>
<span class="kn">from</span> <span class="nn">._indices</span> <span class="kn">import</span> <span class="n">indices_only</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="kn">import</span> <span class="n">get_dtype</span>
<span class="kn">from</span> <span class="nn">.utils.ranges</span> <span class="kn">import</span> <span class="n">list2str</span>
<span class="kn">from</span> <span class="nn">.sparse</span> <span class="kn">import</span> <span class="n">SparseCSR</span><span class="p">,</span> <span class="n">isspmatrix</span><span class="p">,</span> <span class="n">_ncol_to_indptr</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SparseAtom&#39;</span><span class="p">,</span> <span class="s1">&#39;SparseOrbital&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_SparseGeometry</span><span class="p">(</span><span class="n">NDArrayOperatorsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object containing sparse elements for a given geometry.</span>

<span class="sd">    This is a base class intended to be sub-classed because the sparsity information</span>
<span class="sd">    needs to be extracted from the ``_size`` attribute.</span>

<span class="sd">    The sub-classed object _must_ implement the ``_size`` attribute.</span>
<span class="sd">    The sub-classed object may re-implement the ``_cls_kwargs`` routine</span>
<span class="sd">    to pass down keyword arguments when a new class is instantiated.</span>

<span class="sd">    This object contains information regarding the</span>
<span class="sd">     - geometry</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create sparse object with element between orbitals &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>

        <span class="c1"># Initialize the sparsity pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Associated geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecate_method</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*.geom is deprecated, use *.geometry instead&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">geom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; deprecated geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The size of the sparse object &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of rows in the basis &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="k">def</span> <span class="nf">_cls_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Custom keyword arguments when creating a new instance &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The sparsity pattern has all elements removed and everything is reset.</span>

<span class="sd">        The object will be the same as if it had been</span>
<span class="sd">        initialized with the same geometry as it were</span>
<span class="sd">        created with.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, optional</span>
<span class="sd">           number of dimensions per element, default to the current number of</span>
<span class="sd">           elements per matrix element.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           the datatype of the sparse elements</span>
<span class="sd">        nnzpr : int, optional</span>
<span class="sd">           number of non-zero elements per row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I know that this is not the most efficient way to</span>
        <span class="c1"># access a C-array, however, for constructing a</span>
        <span class="c1"># sparse pattern, it should be faster if memory elements</span>
        <span class="c1"># are closer...</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

        <span class="c1"># We check the first atom and its neighbours, we then</span>
        <span class="c1"># select max(5,len(nc) * 4)</span>
        <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nnzpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnzpr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># query dimension of sparse matrix</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">nnzpr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Denote that one *must* specify all details of the elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_nnz</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See :meth:`~sparse.SparseCSR.empty` for details &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">keep_nnz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A copy of this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           it is possible to convert the data to a different data-type</span>
<span class="sd">           If not specified, it will use ``self.dtype``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="c1"># Be sure to copy the content of the SparseCSR object</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of components per element &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shape of sparse matrix &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Data type of sparse elements &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dkind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Data type of sparse elements (in str) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dkind</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of non-zero elements &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>

    <span class="k">def</span> <span class="nf">_translate_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Translates all columns in the `old` cell indices to the `new` cell indices</span>

<span class="sd">        Since the physical matrices are stored in a CSR form, with shape ``(no, no * n_s)`` each</span>
<span class="sd">        block of ``(no, no)`` refers to supercell matrices with an offset according to the internal</span>
<span class="sd">        supercell index.</span>
<span class="sd">        This routine may be used to translate from one sorting of the columns to another sorting of the columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           belong to.</span>
<span class="sd">        new : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           are being transferred to. Must have same length as `old`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">+</span><span class="s2">&quot;.translate_cells requires input and output indices with &quot;</span>
                             <span class="s2">&quot;equal length&quot;</span><span class="p">)</span>

        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Number of elements per matrix</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="n">n</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve edges (connections) for all `atoms`</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.na_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or list of int</span>
<span class="sd">            the edges are returned only for the given atom</span>
<span class="sd">        exclude : int or list of int or None, optional</span>
<span class="sd">           remove edges which are in the `exclude` list.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Representation of the sparse model &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1">dim: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s1">, non-zero: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s1">, kind=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="si">}</span><span class="se">\n</span><span class="s1"> &#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">}&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, dim=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">, nnz=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s2">, kind=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Overload attributes from the hosting geometry</span>

<span class="sd">        Any attribute not found in the sparse class will</span>
<span class="sd">        be looked up in the hosting geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="c1"># Make the indicis behave on the contained sparse matrix</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Delete elements of the sparse elements &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check whether a sparse index is non-zero &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse geometry</span>

<span class="sd">        If one reduces the number of supercells, *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Try first in the new one, then we figure out what to do</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allclose</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Create an array of all things that should be translated</span>
        <span class="n">old</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">deleted</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc_off</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Luckily there are *only* one time wrap-arounds</span>
                <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
                <span class="c1"># Now do translation</span>
                <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Not found, i.e. new, so no need to translate</span>
                <span class="k">pass</span>

        <span class="c1"># 1. Ensure that any one of the *old* supercells that</span>
        <span class="c1">#    are now deleted are put in the end</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">deleted</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Old index (j)</span>
            <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># Move to the end (*HAS* to be higher than the number of</span>
            <span class="c1"># cells in the new supercell structure)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Check that we will translate all indices in the old</span>
        <span class="c1"># sparsity pattern to the new one</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;Not all supercells are accounted for&quot;</span><span class="p">)</span>

        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># Assert that there are only unique values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in old set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in new set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-valid size of in old set_nsc&quot;</span><span class="p">)</span>

        <span class="c1"># Figure out if we need to do any work</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Reduce pivoting work</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

            <span class="c1"># Create the translation tables</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">tile</span><span class="p">([</span><span class="n">size</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>

            <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Move data to new positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">max_n</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Make sure we delete all column values where we have put fake values</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">delete</span><span class="p">,</span> <span class="n">keep_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="n">sc</span><span class="o">.</span><span class="n">n_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_clean_columns</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create the transposed sparse geometry by interchanging supercell indices</span>

<span class="sd">        Sparse geometries are (typically) relying on symmetry in the supercell picture.</span>
<span class="sd">        Thus when one transposes a sparse geometry one should *ideally* get the same</span>
<span class="sd">        matrix. This is true for the Hamiltonian, density matrix, etc.</span>

<span class="sd">        This routine transposes all rows and columns such that any interaction between</span>
<span class="sd">        row, `r`, and column `c` in a given supercell `(i,j,k)` will be transposed</span>
<span class="sd">        into row `c`, column `r` in the supercell `(-i,-j,-k)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort : bool, optional</span>
<span class="sd">           the returned columns for the transposed structure will be sorted</span>
<span class="sd">           if this is true, default</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The components for each sparse element are not changed in this method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Force a sparse geometry to be Hermitian:</span>

<span class="sd">        &gt;&gt;&gt; sp = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; sp = (sp + sp.transpose()) * 0.5</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            an equivalent sparse geometry with transposed matrix elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a temporary copy to put data into</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># clean memory to not crowd memory too much</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Short-links</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span>

        <span class="c1"># Create &quot;DOK&quot; format indices</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="c1"># Number of rows (used for converting to supercell indices)</span>
        <span class="c1"># With this we don&#39;t need to figure out if we are dealing with</span>
        <span class="c1"># atoms or orbitals</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># First extract the actual data</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># figure out rows where ncol is &gt; 0</span>
        <span class="c1"># we skip the first column</span>
        <span class="n">row_nonzero</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">row_nonzero</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">ncol</span><span class="p">[</span><span class="n">row_nonzero</span><span class="p">])</span>

        <span class="c1"># Now we have the DOK format</span>
        <span class="c1">#  row, col, _D</span>

        <span class="c1"># Retrieve all sc-indices in the new transposed array</span>
        <span class="n">new_sc_off</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span> <span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">)</span>

        <span class="c1"># Calculate the row-offsets in the new sparse geometry</span>
        <span class="n">row</span> <span class="o">+=</span> <span class="n">new_sc_off</span><span class="p">[</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">col</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">*</span> <span class="n">size</span>

        <span class="c1"># Now convert columns into unit-cell</span>
        <span class="n">col</span> <span class="o">%=</span> <span class="n">size</span>

        <span class="c1"># Now we can re-create the sparse matrix</span>
        <span class="c1"># All we need is to count the number of non-zeros per column.</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrow</span>
        <span class="k">del</span> <span class="n">rows</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="c1"># also sort individual rows for each column</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">lexsort</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sort columns to get transposed values.</span>
            <span class="c1"># This will randomize the rows</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Our new data will then be</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">row</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">D</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>

        <span class="c1"># If `sort` we have everything sorted, otherwise it</span>
        <span class="c1"># is not ensured</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="n">sort</span>

        <span class="k">return</span> <span class="n">T</span>

    <span class="k">def</span> <span class="nf">spalign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; See :meth:`~sisl.sparse.SparseCSR.align` for details &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseCSR</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eliminate_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes all zero elements from the sparse matrix</span>

<span class="sd">        This is an *in-place* operation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.eliminate_zeros : method called, see there for parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Create iterations on the non-zero elements</span>
    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="n">iter_nnz</span>

    <span class="k">def</span> <span class="nf">create_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a simple function for passing to the `construct` function.</span>

<span class="sd">        This is simply to leviate the creation of simplistic</span>
<span class="sd">        functions needed for setting up the sparse elements.</span>

<span class="sd">        Basically this returns a function:</span>

<span class="sd">        &gt;&gt;&gt; def func(self, ia, atoms, atoms_xyz=None):</span>
<span class="sd">        ...     idx = self.geometry.close(ia, R=R, atoms=atoms, atoms_xyz=atoms_xyz)</span>
<span class="sd">        ...     for ix, p in zip(idx, param):</span>
<span class="sd">        ...         self[ia, ix] = p</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function only works for geometry sparse matrices (i.e. one</span>
<span class="sd">        element per atom). If you have more than one element per atom</span>
<span class="sd">        you have to implement the function your-self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : array_like</span>
<span class="sd">           radii parameters for different shells.</span>
<span class="sd">           Must have same length as `param` or one less.</span>
<span class="sd">           If one less it will be extended with ``R[0]/100``</span>
<span class="sd">        param : array_like</span>
<span class="sd">           coupling constants corresponding to the `R`</span>
<span class="sd">           ranges. ``param[0,:]`` are the elements</span>
<span class="sd">           for the all atoms within ``R[0]`` of each atom.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        construct : routine to create the sparse matrix from a generic function (as returned from `create_construct`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.create_construct got different lengths of `R` and `param`&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">na_iR</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Automatically construct the sparse model based on a function that does the setting up of the elements</span>

<span class="sd">        This may be called in two variants.</span>

<span class="sd">        1. Pass a function (`func`), see e.g. ``create_construct``</span>
<span class="sd">           which does the setting up.</span>
<span class="sd">        2. Pass a tuple/list in `func` which consists of two</span>
<span class="sd">           elements, one is ``R`` the radii parameters for</span>
<span class="sd">           the corresponding parameters.</span>
<span class="sd">           The second is the parameters</span>
<span class="sd">           corresponding to the ``R[i]`` elements.</span>
<span class="sd">           In this second case all atoms must only have</span>
<span class="sd">           one orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable or array_like</span>
<span class="sd">           this function *must* take 4 arguments.</span>
<span class="sd">           1. Is this object (``self``)</span>
<span class="sd">           2. Is the currently examined atom (``ia``)</span>
<span class="sd">           3. Is the currently bounded indices (``idxs``)</span>
<span class="sd">           4. Is the currently bounded indices atomic coordinates (``idxs_xyz``)</span>
<span class="sd">           An example `func` could be:</span>

<span class="sd">           &gt;&gt;&gt; def func(self, ia, atoms, atoms_xyz=None):</span>
<span class="sd">           ...     idx = self.geometry.close(ia, R=[0.1, 1.44], atoms=atoms, atoms_xyz=atoms_xyz)</span>
<span class="sd">           ...     self[ia, idx[0]] = 0</span>
<span class="sd">           ...     self[ia, idx[1]] = -2.7</span>

<span class="sd">        na_iR : int, optional</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method : {&#39;rand&#39;, str}</span>
<span class="sd">           method used in `Geometry.iter_block`, see there for details</span>
<span class="sd">        eta : bool, optional</span>
<span class="sd">           whether an ETA will be printed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        create_construct : a generic function used to create a generic function which this routine requires</span>
<span class="sd">        tile : tiling *after* construct is much faster for very large systems</span>
<span class="sd">        repeat : repeating *after* construct is much faster for very large systems</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Passed `func` which is not a function, nor tuple/list of `R, param`&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Automatically setting a sparse model &quot;</span>
                              <span class="s2">&quot;for systems with atoms having more than 1 &quot;</span>
                              <span class="s2">&quot;orbital *must* be done by your-self. You have to define a corresponding `func`.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert to a proper function</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_construct</span><span class="p">(</span><span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">)</span>

        <span class="c1"># Create eta-object</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.construct&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>

            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for coordinates...</span>
            <span class="n">idxs_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="p">)</span>

            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ias</span><span class="p">))</span>

        <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Whether the contained data is finalized and non-used elements have been removed &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalized</span>

    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by removing the atoms corresponding to `atoms`</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int</span>
<span class="sd">            indices of removed atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        sub : the opposite of `remove`, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by retaining the atoms corresponding to `atoms`</span>

<span class="sd">        Indices passed must be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int</span>
<span class="sd">            indices of removed atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Swaps atoms in the sparse geometry to obtain a new order of atoms</span>

<span class="sd">        This can be used to reorder elements of a geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">             the first list of atomic coordinates</span>
<span class="sd">        b : array_like</span>
<span class="sd">             the second list of atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Create full index list</span>
        <span class="n">full</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span>
        <span class="c1"># Regardless of whether swapping or new indices are requested</span>
        <span class="c1"># this should work.</span>
        <span class="n">full</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">full</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">full</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Finalizes the model</span>

<span class="sd">        Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</span>

<span class="sd">        Note that adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the</span>
<span class="sd">        internal data-representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tocsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a :class:`~scipy.sparse.csr_matrix` for the specified dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, optional</span>
<span class="sd">           the dimension in the sparse matrix (for non-orthogonal cases the last</span>
<span class="sd">           dimension is the overlap matrix)</span>
<span class="sd">        isc : int, optional</span>
<span class="sd">           the supercell index, or all (if ``isc=None``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Requesting sub-sparse has not been implemented yet&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spsame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compare two sparse objects and check whether they have the same entries.</span>

<span class="sd">        This does not necessarily mean that the elements are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromsp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse model from a preset `Geometry` and a list of sparse matrices</span>

<span class="sd">        The passed sparse matrices are in one of `scipy.sparse` formats.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry</span>
<span class="sd">           geometry to describe the new sparse geometry</span>
<span class="sd">        P : list of scipy.sparse or scipy.sparse</span>
<span class="sd">           the new sparse matrices that are to be populated in the sparse</span>
<span class="sd">           matrix</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">           any arguments that are directly passed to the ``__init__`` method</span>
<span class="sd">           of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseGeometry</span>
<span class="sd">             a new sparse matrix that holds the passed geometry and the elements of `P`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure list of * format (to get dimensions)</span>
        <span class="k">if</span> <span class="n">isspmatrix</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="o">*</span><span class="n">P</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">_size</span> <span class="o">!=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.fromsp cannot create a new class, the geometry &quot;</span>
                             <span class="s2">&quot;and sparse matrices does not have coinciding dimensions size != P[0].shape[0]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p</span>

    <span class="c1"># numpy dispatch methods (same priority as SparseCSR!)</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">14</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># grab the inputs and convert to the respective csr matrices</span>
        <span class="c1"># such that we can defer the call to that function</span>
        <span class="c1"># while converting, also grab the first _SparseGeometry</span>
        <span class="c1"># object such that we may create the output matrix</span>
        <span class="n">sp_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
                <span class="c1"># simply store a reference</span>
                <span class="c1"># if needed we will copy it later</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">inp</span>
                <span class="n">sp_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sp_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">out</span><span class="p">,)</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">_csr</span><span class="p">,)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">sp_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span>
            <span class="s1">&#39;csr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return dictionary with the current state &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;csr&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">csr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SparseAtom</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object with number of rows equal to the total number of atoms in the `Geometry` &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Elements for the index(s) &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

<div class="viewcode-block" id="SparseAtom.nonzero"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like of int, optional</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">        only_col : bool, optional</span>
<span class="sd">           only return then non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseAtom.iter_nnz"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.iter_nnz">[docs]</a>    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseAtom.set_nsc"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.set_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse atom</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseAtom.cut"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cuts the sparse atom model into different parts.</span>

<span class="sd">        Recreates a new sparse atom object with only the cutted</span>
<span class="sd">        atoms in the structure.</span>

<span class="sd">        Cutting is the opposite of tiling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps : int</span>
<span class="sd">           number of times the structure will be cut</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis that will be cut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c1"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="c1"># Create new cut geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">):</span>
                    <span class="n">new_w</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                    <span class="n">new_w</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;The sparse atom cannot be cut as the structure &quot;</span>
                              <span class="s2">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                              <span class="s2">&quot;relieved from sisl.&quot;</span><span class="p">)</span>
                    <span class="n">warn</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span>

        <span class="c1"># Now we need to re-create number of supercells</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># First we need to figure out how long the interaction range is</span>
        <span class="c1"># in the cut-direction</span>
        <span class="c1"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># we count the new direction</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># Get supercell index</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># TODO this is inconsistent if seg= is used as argument</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">na</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[:]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># figure out how many cells it is connecting to</span>
            <span class="n">ncell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sub</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">na</span>
            <span class="k">for</span> <span class="n">icell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncell</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">icell</span>
                <span class="c1"># We need to ensure that every &quot;in between&quot; index exists</span>
                <span class="c1"># if it does not we discard those indices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">sub</span><span class="p">,</span>
                                      <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ncell</span> <span class="o">=</span> <span class="n">icell</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span> <span class="o">+</span> <span class="n">ncell</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cut the connection at nsc=</span><span class="si">{}</span><span class="s1"> in direction </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>

        <span class="c1"># Update number of super-cells</span>
        <span class="n">nsc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now we have a correct geometry, and</span>
        <span class="c1"># we are now ready to create the sparsity pattern</span>
        <span class="c1"># Reduce the sparsity pattern, first create the new one</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">_sca2sca</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
            <span class="c1"># Converts an o from M to m</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span>
            <span class="c1"># Correct for cell-offset</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">M</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">//</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span>
            <span class="c1"># find the equivalent cell in m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If a fail happens it is due to a discarded</span>
                <span class="c1"># interaction across a non-interacting region</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># only loop on the atoms remaining in the cutted structure</span>
        <span class="k">for</span> <span class="n">ja</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)):</span>

            <span class="c1"># Get the equivalent orbital in the smaller cell</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">afp</span><span class="p">,</span> <span class="n">afm</span> <span class="o">=</span> <span class="n">_sca2sca</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ja</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span>
            <span class="n">S</span><span class="p">[</span><span class="n">ja</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">afp</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="c1"># TODO check that we indeed have Hermiticity for non-collinear and spin-orbit</span>
            <span class="n">S</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">ja</span> <span class="o">+</span> <span class="n">afm</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.sub"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by only retaining the elements corresponding to the `atoms`</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int</span>
<span class="sd">            indices of retained atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : the negative of `Geometry.sub`</span>
<span class="sd">        Geometry.sub : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="c1"># Use broadcasting rules</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.tile"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a tiled sparse atom object, equivalent to `Geometry.tile`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calling this routine will automatically `finalize` the `SparseAtom`. This</span>
<span class="sd">        is required to greatly increase performance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.tile: the same ordering as the final geometry</span>
<span class="sd">        Geometry.repeat: a different ordering of the final geometry</span>
<span class="sd">        repeat: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">na_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JA</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">na</span> <span class="o">*</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="c1"># Correct the supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">JA</span><span class="p">,</span> <span class="n">na_n</span><span class="p">)</span>

            <span class="n">indices</span><span class="p">[</span><span class="n">rep</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">na_n</span>

            <span class="c1"># Step atoms</span>
            <span class="n">JA</span> <span class="o">+=</span> <span class="n">na</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JA</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.repeat"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a repeated sparse atom object, equivalent to `Geometry.repeat`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.repeat: the same ordering as the final geometry</span>
<span class="sd">        Geometry.tile: a different ordering of the final geometry</span>
<span class="sd">        tile: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">na_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JA</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span>
        <span class="c1"># Get the offset atoms</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>

            <span class="c1"># Update the offset</span>
            <span class="n">A</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Correct supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>

            <span class="c1"># Create the indices for the repetition</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">rep</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">reps</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">JA</span> <span class="o">+</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">na_n</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JA</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># In the repeat we have to tile individual atomic couplings</span>
        <span class="c1"># So we should split the arrays and tile them individually</span>
        <span class="c1"># Now D is made up of D values, per atom</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ntile</span> <span class="o">=</span> <span class="n">ftool</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ntile</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumi</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))))</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseAtom.rij"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the distance between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseAtom.Rij"><a class="viewcode-back" href="../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with vectors between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="c1"># Create the output class</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Re-create the sparse matrix data</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">ia</span><span class="p">])</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">R</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SparseOrbital</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Sparse object with number of rows equal to the total number of orbitals in the `Geometry` &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Elements for the index(s) &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>

<div class="viewcode-block" id="SparseOrbital.edges"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve edges (connections) for all `atoms`</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.no_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or list of int</span>
<span class="sd">            the edges are returned only for the given atom (but by using  all orbitals of the</span>
<span class="sd">            requested atom). The returned edges are also atoms.</span>
<span class="sd">        exclude : int or list of int or None, optional</span>
<span class="sd">           remove edges which are in the `exclude` list, this list refers to orbitals.</span>
<span class="sd">        orbital : int or list of int</span>
<span class="sd">            the edges are returned only for the given orbital. The returned edges are orbitals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.edges must have either &#39;atom&#39; or &#39;orbital&#39; keyword defined.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">exclude</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.nonzero"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like of int, optional</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">           But for *all* orbitals.</span>
<span class="sd">        only_col : bool, optional</span>
<span class="sd">           only return then non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span> <span class="n">only_col</span><span class="o">=</span><span class="n">only_col</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.iter_nnz"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.iter_nnz">[docs]</a>    <span class="k">def</span> <span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbitals</span>
<span class="sd">            on these atoms (not compatible with the `orbitals` keyword)</span>
<span class="sd">        orbitals : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbital</span>
<span class="sd">            (not compatible with the `atoms` keyword)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.set_nsc"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.set_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reset the number of allowed supercells in the sparse orbital</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `SuperCell.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.cut"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Cuts the sparse orbital model into different parts.</span>

<span class="sd">        Recreates a new sparse orbital object with only the cutted</span>
<span class="sd">        atoms in the structure.</span>

<span class="sd">        Cutting is the opposite of tiling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seps : int</span>
<span class="sd">           number of times the structure will be cut</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis that will be cut</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_w</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c1"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="c1"># Create new cut geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">):</span>
                    <span class="n">new_w</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
                    <span class="n">new_w</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;The sparse orbital cannot be cut as the structure &quot;</span>
                              <span class="s2">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                              <span class="s2">&quot;relieved from sisl.&quot;</span><span class="p">)</span>
                    <span class="n">warn</span><span class="p">(</span><span class="n">new_w</span><span class="p">)</span>

        <span class="c1"># Now we need to re-create number of supercells</span>
        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># First we need to figure out how long the interaction range is</span>
        <span class="c1"># in the cut-direction</span>
        <span class="c1"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># we count the new direction</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
            <span class="c1"># Get supercell index</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># TODO this is inconsistent if seg= is used as argument</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">no</span><span class="p">:(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[:]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># figure out how many cells it is connecting to</span>
            <span class="n">ncell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sub</span> <span class="o">%</span> <span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">no</span>
            <span class="k">for</span> <span class="n">icell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncell</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="n">icell</span>
                <span class="c1"># We need to ensure that every &quot;in between&quot; index exists</span>
                <span class="c1"># if it does not we discard those indices</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">sub</span><span class="p">,</span>
                                      <span class="n">sub</span> <span class="o">&lt;</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ncell</span> <span class="o">=</span> <span class="n">icell</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span> <span class="o">+</span> <span class="n">ncell</span>

            <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cut the connection at nsc=</span><span class="si">{}</span><span class="s1"> in direction </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">))</span>

        <span class="c1"># Update number of super-cells</span>
        <span class="n">nsc</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[:]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now we have a correct geometry, and</span>
        <span class="c1"># we are now ready to create the sparsity pattern</span>
        <span class="c1"># Reduce the sparsity pattern, first create the new one</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">_sco2sco</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
            <span class="c1"># Converts an o from M to m</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">seps</span>
            <span class="c1"># Correct for cell-offset</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">o</span> <span class="o">%</span> <span class="n">M</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span>
            <span class="c1"># find the equivalent cell in m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If a fail happens it is due to a discarded</span>
                <span class="c1"># interaction across a non-interacting region</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">o</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">,</span>
                        <span class="n">m</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># only loop on the orbitals remaining in the cutted structure</span>
        <span class="k">for</span> <span class="n">jo</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)):</span>

            <span class="c1"># Get the equivalent orbital in the smaller cell</span>
            <span class="n">o</span><span class="p">,</span> <span class="n">ofp</span><span class="p">,</span> <span class="n">ofm</span> <span class="o">=</span> <span class="n">_sco2sco</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">seps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span> <span class="n">io</span><span class="p">]</span>
            <span class="n">S</span><span class="p">[</span><span class="n">jo</span><span class="p">,</span> <span class="n">o</span> <span class="o">+</span> <span class="n">ofp</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="c1"># TODO check that we indeed have Hermiticity for non-collinear and spin-orbit</span>
            <span class="n">S</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="n">jo</span> <span class="o">+</span> <span class="n">ofm</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.remove"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subset of this sparse matrix by only retaining the atoms corresponding to `atoms`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of removed atoms or Atom for direct removal of all atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        Geometry.sub : the negative of `Geometry.remove`</span>
<span class="sd">        sub : the opposite of `remove`, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This will digress to call .sub</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.remove_orbital"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.remove_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">remove_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove a subset of orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        For more detailed examples, please see the equivalent (but opposite) method</span>
<span class="sd">        `sub_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are removed from the sparse matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub_orbital : retaining a set of orbitals (see here for examples)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom (convert to list of indices)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="c1"># We know np.all(geom.atoms[atom] == old_atom)</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># now call sub_orbital</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.sub"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a subset of this sparse matrix by only retaining the atoms corresponding to `atoms`</span>

<span class="sd">        Negative indices are wrapped and thus works, supercell atoms are also wrapped to the unit-cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of retained atoms or `Atom` for retaining only *that* atom</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; obj.sub(1) # only retain the second atom in the SparseGeometry</span>
<span class="sd">        &gt;&gt;&gt; obj.sub(obj.atoms.atom[0]) # retain all atoms which is equivalent to</span>
<span class="sd">        &gt;&gt;&gt;                            # the first atomic specie</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.remove : the negative of `Geometry.sub`</span>
<span class="sd">        Geometry.sub : equivalent to the resulting `Geometry` from this routine</span>
<span class="sd">        remove : the negative of `sub`, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="c1"># Use broadcasting rules</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.sub_orbital"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.sub_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">sub_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Retain only a subset of the orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        This allows one to retain only a given subset of the sparse matrix elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are retained in the sparse matrix, the list of</span>
<span class="sd">            orbitals will be sorted. One cannot re-arrange matrix elements currently.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Future implementations may allow one to re-arange orbitals using this method.</span>

<span class="sd">        When using this method the internal species list will be populated by another specie</span>
<span class="sd">        that is named after the orbitals removed. This is to distinguish different atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; # a Carbon atom with 2 orbitals</span>
<span class="sd">        &gt;&gt;&gt; C = sisl.Atom(&#39;C&#39;, [1., 2.])</span>
<span class="sd">        &gt;&gt;&gt; # an oxygen atom with 3 orbitals</span>
<span class="sd">        &gt;&gt;&gt; O = sisl.Atom(&#39;O&#39;, [1., 2., 2.4])</span>
<span class="sd">        &gt;&gt;&gt; geometry = sisl.Geometry([[0] * 3, [1] * 3]], 2, [C, O])</span>
<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(geometry).tile(3, 0)</span>
<span class="sd">        &gt;&gt;&gt; # fill in obj data...</span>

<span class="sd">        Now ``obj`` is a sparse geometry with 2 different species and 6 atoms (3 of each).</span>
<span class="sd">        They are ordered ``[C, O, C, O, C, O]``. In the following we</span>
<span class="sd">        will note species that are different from the original by a ``&#39;`` in the list.</span>

<span class="sd">        Retain 2nd orbital on the 2nd atom: ``[C, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(1, 1)</span>

<span class="sd">        Retain 2nd orbital on 1st and 2nd atom: ``[C&#39;, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital([0, 1], 1)</span>

<span class="sd">        Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: ``[C&#39;, O, C, O&#39;, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(0, 1).sub_orbital(3, 2)</span>

<span class="sd">        Retain 2nd orbital on all atoms equivalent to the first atom: ``[C&#39;, O, C&#39;, O, C&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(obj.geometry.atoms[0], 1)</span>

<span class="sd">        Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: ``[C&#39;, O, C&#39;&#39;, O, C&#39;&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(0, 0).sub_orbital([2, 4], 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_orbital : removing a set of orbitals (opposite of this)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># At this point we are sure that uniq_specie is *only* one specie!</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">SG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">old_atom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">orbitals</span><span class="p">)</span>
        <span class="c1"># Find orbitals to remove (note this HAS to be from the original array)</span>
        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Generate a list of orbitals to retain</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span>

        <span class="c1"># Generate full supercell indices</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">SG</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">)</span>

        <span class="c1"># just ensure we are doing the correct thing</span>
        <span class="k">assert</span> <span class="n">SG</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">SG</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>

        <span class="k">return</span> <span class="n">SG</span></div>

<div class="viewcode-block" id="SparseOrbital.tile"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a tiled sparse orbital object, equivalent to `Geometry.tile`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.tile: the same ordering as the final geometry</span>
<span class="sd">        Geometry.repeat: a different ordering of the final geometry</span>
<span class="sd">        repeat: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">no_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># atoms in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ncol</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting atom in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JO</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">no</span> <span class="o">*</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="c1"># Correct the supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">JO</span><span class="p">,</span> <span class="n">no_n</span><span class="p">)</span>

            <span class="n">indices</span><span class="p">[</span><span class="n">rep</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">no_n</span>

            <span class="c1"># Step orbitals</span>
            <span class="n">JO</span> <span class="o">+=</span> <span class="n">no</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JO</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">tile</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">indices</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">no_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.repeat"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a repeated sparse orbital object, equivalent to `Geometry.repeat`</span>

<span class="sd">        The already existing sparse elements are extrapolated</span>
<span class="sd">        to the new supercell by repeating them in blocks like the coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of repetitions along cell-vector `axis`</span>
<span class="sd">        axis : int</span>
<span class="sd">            0, 1, 2 according to the cell-direction</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Geometry.repeat: the same ordering as the final geometry</span>
<span class="sd">        Geometry.tile: a different ordering of the final geometry</span>
<span class="sd">        tile: a different ordering of the final geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the new sparse object</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="c1"># Now begin to populate it accordingly</span>
        <span class="c1"># Retrieve local pointers to the information</span>
        <span class="c1"># regarding the current Hamiltonian sparse matrix</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="ow">or</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># Information for the new Hamiltonian sparse matrix</span>
        <span class="n">no_n</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">geom_n</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># First loop on axis tiling and local</span>
        <span class="c1"># orbitals in the geometry</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">sc_index</span>

        <span class="c1"># Create new indptr, indices and D</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">reps</span><span class="p">),</span>
                           <span class="n">repeat</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">reps</span><span class="p">))</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># Now indptr is complete</span>
        <span class="n">indptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Note that D above is already reduced to a *finalized* state</span>
        <span class="c1"># So we have to re-create the reduced index pointer</span>
        <span class="c1"># Then we take repeat the data by smart indexing</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">array_arange</span><span class="p">(</span><span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)[</span><span class="n">idx</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">),</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">idx</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="n">indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Now we should fill the data</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="c1"># resulting orbital in the new geometry (without wrapping</span>
        <span class="c1"># for correct supercell, that will happen below)</span>
        <span class="n">JO</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="n">no</span>
        <span class="c1"># Get number of orbitals per atom (lasto - firsto + 1)</span>
        <span class="c1"># This is faster than the direct call</span>

        <span class="n">ja</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">JO</span><span class="p">)</span>
        <span class="n">oJ</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">ja</span><span class="p">]</span>
        <span class="n">oA</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">ja</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">oJ</span>
        <span class="c1"># Shift the orbitals corresponding to the</span>
        <span class="c1"># repetitions of all previous atoms</span>
        <span class="n">JO</span> <span class="o">+=</span> <span class="n">oJ</span> <span class="o">*</span> <span class="p">(</span><span class="n">reps</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Get the offset orbitals</span>
        <span class="n">O</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># We need to create and indexable atomic array</span>
        <span class="c1"># This is required for multi-orbital cases where</span>
        <span class="c1"># we should tile atomic orbitals, and repeat the atoms (only).</span>
        <span class="c1"># &#39;A&#39; is now the first (non-repeated) atom in the new structure</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span> <span class="o">*</span> <span class="n">reps</span>
        <span class="n">AO</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># subtract AO for first iteration in repetition loop</span>
        <span class="n">OA</span> <span class="o">=</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="n">AO</span>

        <span class="c1"># Clean</span>
        <span class="k">del</span> <span class="n">ja</span><span class="p">,</span> <span class="n">oJ</span><span class="p">,</span> <span class="n">A</span>

        <span class="c1"># Get view of ncol</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>

        <span class="c1"># Create repetitions</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>

            <span class="c1"># Update atomic offset</span>
            <span class="n">OA</span> <span class="o">+=</span> <span class="n">AO</span>
            <span class="c1"># Update the offset</span>
            <span class="n">O</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Correct supercell information</span>
            <span class="n">isc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>

            <span class="c1"># Create the indices for the repetition</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">array_arange</span><span class="p">(</span><span class="n">OA</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">AO</span><span class="p">)],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">JO</span> <span class="o">+</span> <span class="n">oA</span> <span class="o">*</span> <span class="n">mod</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">*</span> <span class="n">no_n</span>

        <span class="c1"># Clean-up</span>
        <span class="k">del</span> <span class="n">isc</span><span class="p">,</span> <span class="n">JO</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">OA</span><span class="p">,</span> <span class="n">AO</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># In the repeat we have to tile individual atomic couplings</span>
        <span class="c1"># So we should split the arrays and tile them individually</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span>
                           <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_n</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom_n</span><span class="o">.</span><span class="n">no_s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">S</span></div>

<div class="viewcode-block" id="SparseOrbital.rij"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the distance between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse distance matrix to return, either an atomic distance matrix</span>
<span class="sd">            or an orbital distance matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same distance repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseOrbital.Rij"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a sparse matrix with the vectors between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse vector matrix to return, either an atomic vector matrix</span>
<span class="sd">            or an orbital vector matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same vectors repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>
            <span class="n">o2a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span>

            <span class="c1"># Orbitals</span>
            <span class="n">orow</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Loop on orbitals and atoms</span>
            <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orow</span><span class="p">,</span> <span class="n">o2a</span><span class="p">(</span><span class="n">orow</span><span class="p">)):</span>
                <span class="n">coln</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">o2a</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]:</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span><span class="o">+</span><span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">]]))</span>
                <span class="n">R</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orbital&#39;</span><span class="p">,</span> <span class="s1">&#39;orb&#39;</span><span class="p">]:</span>
            <span class="c1"># We create an *exact* copy of the Rij</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">oRij</span>

            <span class="c1"># Re-create the sparse matrix data</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>

            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">])</span>
                <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.Rij &quot;what&quot; is not one of [atom, orbital].&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="SparseOrbital.add"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Add two sparse matrices by adding the parameters to one set. The final matrix will have no couplings between `self` and `other`</span>

<span class="sd">        The final sparse matrix will not have any couplings between `self` and `other`. Not even if they</span>
<span class="sd">        have commensurate overlapping regions. If you want to create couplings you have to use `append` but that</span>
<span class="sd">        requires the structures are commensurate in the coupling region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : SparseGeometry</span>
<span class="sd">            the other sparse matrix to be added, all atoms will be appended</span>
<span class="sd">        axis : int or None, optional</span>
<span class="sd">            whether a specific axis of the cell will be added to the final geometry.</span>
<span class="sd">            For ``None`` the final cell will be that of `self`, otherwise the lattice</span>
<span class="sd">            vector corresponding to `axis` will be appended.</span>
<span class="sd">        offset : (3,), optional</span>
<span class="sd">            offset in geometry of `other` when adding the atoms.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append : append two matrices by also adding overlap couplings</span>
<span class="sd">        prepend : see `append`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the sparse matrices are compatible</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;.add requires other to be of same type: </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.add requires the same datatypes in the two matrices.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.add requires the same number of dimensions in the matrix.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Same effect but also adds the lattice vectors</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Now we have the correct geometry, then create the correct</span>
        <span class="c1"># class</span>
        <span class="c1"># New indices and data (the constructor for SparseCSR copies)</span>
        <span class="n">full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Retrieve the maximum number of orbitals (in the supercell)</span>
        <span class="c1"># This may be used to remove couplings</span>
        <span class="n">full_no_s</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span>

        <span class="c1"># Now we have to transfer the indices to the new sparse pattern</span>

        <span class="c1"># First create a local copy of the columns, then we transfer, and then we collect.</span>
        <span class="n">s_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Remove couplings along axis</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Tell the routine to delete these indices</span>
            <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Same for the other, but correct for deleted supercells and supercells along</span>
        <span class="c1"># disconnected auxiliary cells.</span>
        <span class="n">o_col</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>

        <span class="c1"># Transfer the correct supercells</span>
        <span class="n">o_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">idx_delete</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">isc</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
                <span class="n">o_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">idx_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
        <span class="c1"># o_idx are transferred to s_idx</span>
        <span class="n">transfer_idx</span><span class="p">[</span><span class="n">o_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">s_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Remove some columns</span>
        <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx_delete</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Clean-up to not confuse the rest of the algorithm</span>
        <span class="k">del</span> <span class="n">o_idx</span><span class="p">,</span> <span class="n">s_idx</span><span class="p">,</span> <span class="n">idx_delete</span>

        <span class="c1"># Now figure out if the supercells can be kept, at all...</span>
        <span class="c1"># find SC indices in other corresponding to self</span>
        <span class="n">o_idx_uc</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">o_idx_sc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="c1"># Remove couplings along axis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]):</span>
                <span class="c1"># This will happen in case `axis` is None</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># When axis is not specified and cell parameters</span>
                <span class="c1"># are commensurate, then we will not change couplings</span>
                <span class="k">continue</span>
            <span class="c1"># Tell the routine to delete these indices</span>
            <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Now we need to decide whether the</span>
        <span class="k">del</span> <span class="n">transfer_idx</span><span class="p">,</span> <span class="n">idx</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span><span class="p">])</span>

        <span class="c1"># Clean up (they could potentially be very large arrays)</span>
        <span class="k">del</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span>

        <span class="c1"># Ensure we remove the elements</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_clean_columns</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">full</span></div>

<div class="viewcode-block" id="SparseOrbital.prepend"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; See `append` for details</span>

<span class="sd">        This is currently equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; other.append(self, axis, eps, scale)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseOrbital.append"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Append `other` along `axis` to construct a new connected sparse matrix</span>

<span class="sd">        This method tries to append two sparse geometry objects together by</span>
<span class="sd">        the following these steps:</span>

<span class="sd">        1. Create the new extended geometry</span>
<span class="sd">        2. Use neighbor cell couplings from `self` as the couplings to `other`</span>
<span class="sd">           This *may* cause problems if the coupling atoms are not exactly equi-positioned.</span>
<span class="sd">           If the coupling coordinates and the coordinates in `other` differ by more than</span>
<span class="sd">           0.01 Ang, a warning will be issued.</span>
<span class="sd">           If this difference is above `eps` the couplings will be removed.</span>

<span class="sd">        When appending sparse matrices made up of atoms, this method assumes that</span>
<span class="sd">        the orbitals on the overlapping atoms have the same orbitals, as well as the</span>
<span class="sd">        same orbital ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sporb = SparseOrbital(....)</span>
<span class="sd">        &gt;&gt;&gt; sporb2 = sporb.append(sporb, 0)</span>
<span class="sd">        &gt;&gt;&gt; sporbt = sporb.tile(2, 0)</span>
<span class="sd">        &gt;&gt;&gt; sporb2.spsame(sporbt)</span>
<span class="sd">        True</span>

<span class="sd">        To retain couplings only from the *left* sparse matrix, do:</span>

<span class="sd">        &gt;&gt;&gt; sporb = left.append(right, 0, scale=(2, 0))</span>
<span class="sd">        &gt;&gt;&gt; sporb = (sporb + sporb.transpose()) * 0.5</span>

<span class="sd">        To retain couplings only from the *right* sparse matrix, do:</span>

<span class="sd">        &gt;&gt;&gt; sporb = left.append(right, 0, scale=(0, 2.))</span>
<span class="sd">        &gt;&gt;&gt; sporb = (sporb + sporb.transpose()) * 0.5</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The current implementation does not preserve the hermiticity of the matrix.</span>
<span class="sd">        If you want to preserve hermiticity of the matrix you have to do the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; sm = (sm + sm.transpose()) / 2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            must be an object of the same type as `self`</span>
<span class="sd">        axis : int</span>
<span class="sd">            axis to append the two sparse geometries along</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            tolerance that all coordinates *must* be within to allow an append.</span>
<span class="sd">            It is important that this value is smaller than half the distance between</span>
<span class="sd">            the two closests atoms such that there is no ambiguity in selecting</span>
<span class="sd">            equivalent atoms. An internal stricter eps is used as a baseline, see above.</span>
<span class="sd">        scale : float or array_like, optional</span>
<span class="sd">            the scale used for the overlapping region. For scalar values it corresponds</span>
<span class="sd">            to passing: ``(scale, scale)``.</span>
<span class="sd">            For array-like input ``scale[0]`` refers to the scale of the matrix elements</span>
<span class="sd">            coupling from `self`, while ``scale[1]`` is the scale of the matrix elements</span>
<span class="sd">            in `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepend : equivalent scheme as this method</span>
<span class="sd">        add : merge two matrices without considering overlap or commensurability</span>
<span class="sd">        transpose : ensure hermiticity by using this routine</span>
<span class="sd">        replace : replace a sub-set of atoms with another sparse matrix</span>
<span class="sd">        Geometry.append</span>
<span class="sd">        Geometry.prepend</span>
<span class="sd">        SparseCSR.scale_columns : method used to scale the two matrix elements values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a new instance with two sparse matrices joined and appended together</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires other to be of same type: </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires sparse-geometries to maximally &quot;</span>
                             <span class="s2">&quot;have 3 supercells along appending axis.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires sparse-geometries to have the same &quot;</span>
                             <span class="s2">&quot;number of supercells along all directions.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_isc_off</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">_isc_off</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires supercell offsets to be the same.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the same datatypes in the two matrices.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the same number of dimensions in the matrix.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Our procedure will be to separate the sparsity patterns into separate chunks</span>
        <span class="c1"># First generate the full geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># create the new sparsity patterns with offset</span>

        <span class="c1"># New indices and data (the constructor for SparseCSR copies)</span>
        <span class="n">full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># First create a local copy of the columns, then we transfer, and then we collect.</span>
        <span class="n">s_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># transfer</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="n">o_col</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># transfer</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Store all column indices</span>
        <span class="k">del</span> <span class="n">transfer_idx</span><span class="p">,</span> <span class="n">idx</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span><span class="p">))</span>

        <span class="c1"># Clean up (they could potentially be very large arrays)</span>
        <span class="k">del</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span>

        <span class="c1"># Now everything is contained in 1 sparse matrix.</span>
        <span class="c1"># All matrix elements are as though they are in their own</span>

        <span class="c1"># What needs to be done is to find the overlapping atoms and transfer indices in</span>
        <span class="c1"># both these sparsity patterns to the correct elements.</span>

        <span class="c1"># 1. find overlapping atoms along axis</span>
        <span class="n">idx_s_first</span><span class="p">,</span> <span class="n">idx_o_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">idx_s_last</span><span class="p">,</span> <span class="n">idx_o_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                                       <span class="n">offset</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:],</span>
                                                       <span class="n">offset_other</span><span class="o">=-</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># IFF idx_s_* contains duplicates, then we have multiple overlapping atoms which is not</span>
        <span class="c1"># allowed</span>
        <span class="k">def</span> <span class="nf">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">diff</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires that there is maximally one &quot;</span>
                                 <span class="s2">&quot;atom overlapping one other atom in the other structure.&quot;</span><span class="p">)</span>
        <span class="n">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_s_first</span><span class="p">))</span>
        <span class="n">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_s_last</span><span class="p">))</span>
        <span class="c1"># Also ensure that atoms have the same number of orbitals in the two cases</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_s_first</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_o_first</span><span class="p">]))</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_s_last</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_o_last</span><span class="p">])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the overlapping geometries &quot;</span>
                             <span class="s2">&quot;to have the same number of orbitals per atom that is to be replaced.&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_edges_and_coordinates</span><span class="p">(</span><span class="n">spgeom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">err_help</span><span class="p">):</span>
            <span class="c1"># Figure out if we have found all couplings</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">spgeom</span><span class="o">.</span><span class="n">geometry</span>
            <span class="c1"># Find orbitals that we wish to exclude from the orbital connections</span>
            <span class="c1"># This ensures that we only find couplings crossing the supercell boundaries</span>
            <span class="n">irrelevant_sc</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">))</span>
            <span class="n">sc_orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="n">sc_orbitals</span><span class="p">[</span><span class="n">irrelevant_sc</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># get connections and transfer them to the unit-cell</span>
            <span class="n">edges_sc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">spgeom</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">edges_uc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">edges_sc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">edges_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges_uc</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">edges_valid</span><span class="p">):</span>
                <span class="n">edges_uc</span> <span class="o">=</span> <span class="n">edges_sc</span> <span class="o">%</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
                <span class="c1"># Reduce edges to those that are faulty</span>
                <span class="n">edges_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges_uc</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="n">edges_sc</span><span class="p">[</span><span class="o">~</span><span class="n">edges_valid</span><span class="p">]</span>
                <span class="c1"># Get supercell offset and unit-cell atom</span>
                <span class="n">isc_off</span><span class="p">,</span> <span class="n">uca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
                <span class="c1"># group atoms for each supercell index</span>
                <span class="c1"># find unique supercell offsets</span>
                <span class="n">sc_off_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># This will be much faster</span>
                <span class="k">for</span> <span class="n">isc</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">(</span><span class="n">isc_off</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">isc_off</span> <span class="o">==</span> <span class="n">isc</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sc_off_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{k}</span><span class="s2">: </span><span class="si">{v}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">isc</span><span class="p">]),</span>
                        <span class="n">v</span><span class="o">=</span><span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">uca</span><span class="p">[</span><span class="n">idx</span><span class="p">]))))</span>
                <span class="n">sc_off_atoms</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sc_off_atoms</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires matching coupling elements.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;The following atoms in a </span><span class="si">{</span><span class="n">err_help</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> connection of `</span><span class="si">{</span><span class="n">err_help</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">` super-cell &quot;</span>
                                 <span class="s2">&quot;are connected from the unit cell, but are not found in matches:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;[sc-offset]: atoms</span><span class="se">\n</span><span class="s2">   </span><span class="si">{</span><span class="n">sc_off_atoms</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># setup supercells to look up</span>
        <span class="n">isc_inplace</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">isc_inplace</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">isc_forward</span> <span class="o">=</span> <span class="n">isc_inplace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">isc_forward</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">isc_back</span> <span class="o">=</span> <span class="n">isc_inplace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">isc_back</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Check that edges and overlapping atoms are the same (or at least that the</span>
        <span class="c1"># edges are all in the overlapping region)</span>
        <span class="c1"># [self|other]: self sc-connections forward must be on left-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_s_first</span><span class="p">,</span> <span class="n">isc_forward</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;forward&quot;</span><span class="p">))</span>
        <span class="c1"># [other|self]: other sc-connections forward must be on left-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">idx_o_first</span><span class="p">,</span> <span class="n">isc_forward</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;forward&quot;</span><span class="p">))</span>
        <span class="c1"># [other|self]: self sc-connections backward must be on right-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_s_last</span><span class="p">,</span> <span class="n">isc_back</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;backward&quot;</span><span class="p">))</span>
        <span class="c1"># [self|other]: other sc-connections backward must be on right-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">idx_o_last</span><span class="p">,</span> <span class="n">isc_back</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;backward&quot;</span><span class="p">))</span>

        <span class="c1"># Now we have ensured that the overlapping coordinates and the connectivity graph</span>
        <span class="c1"># co-incide and that we can actually perform the merge.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="k">def</span> <span class="nf">_sc_index_sort</span><span class="p">(</span><span class="n">isc</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="c1"># Now sort so that all indices are corresponding one2one</span>
            <span class="c1"># This is important since two different supercell indices</span>
            <span class="c1"># need not be sorted in the same manner.</span>
            <span class="c1"># This ensures that there is a correspondance between</span>
            <span class="c1"># two different sparse elements</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">off</span><span class="p">)]</span>

        <span class="n">idx_iscP</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_forward</span><span class="p">)]</span>
        <span class="n">idx_isc0</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_inplace</span><span class="p">)]</span>
        <span class="n">idx_iscM</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_back</span><span class="p">)]</span>
        <span class="c1"># Clean (for me to know what to do in this code)</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_sc_index_sort</span>

        <span class="c1"># First scale all values</span>
        <span class="n">idx_s_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_s_first</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_s_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_s_last</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(((</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                           <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">idx_o_first</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_o_first</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">idx_o_last</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_o_last</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(((</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                           <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Clean up (they may be very large)</span>
        <span class="k">del</span> <span class="n">col</span>

        <span class="c1"># Now we can easily build from-&gt;to arrays</span>

        <span class="c1"># other[0] -&gt; other[1] changes to other[0] -&gt; full_G[1] | self[1]</span>
        <span class="c1"># self[0] -&gt; self[1] changes to self[0] -&gt; full_G[0] | other[0]</span>
        <span class="c1"># self[0] -&gt; self[-1] changes to self[0] -&gt; full_G[-1] | other[-1]</span>
        <span class="c1"># other[0] -&gt; other[-1] changes to other[0] -&gt; full_G[0] | self[0]</span>
        <span class="n">col_from</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(((</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="p">(</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">col_to</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(((</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="p">(</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_isc0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                              <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_isc0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">col_from</span><span class="p">,</span> <span class="n">col_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full</span></div>

<div class="viewcode-block" id="SparseOrbital.replace"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">other_atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Replace `atoms` in `self` with `other_atoms` in `other` and retain couplings between them</span>

<span class="sd">        This method replaces a subset of atoms in `self` with</span>
<span class="sd">        another sparse geometry retaining any couplings between them.</span>
<span class="sd">        The algorithm checks whether the coupling atoms have the same number of</span>
<span class="sd">        orbitals. Meaning that atoms in the overlapping region should have the same</span>
<span class="sd">        connections and number of orbitals per atom.</span>
<span class="sd">        It will _not_ check whether the orbitals or atoms _are_ the same, nor the order</span>
<span class="sd">        of the orbitals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; minimal = SparseOrbital(....)</span>
<span class="sd">        &gt;&gt;&gt; big = minimal.tile(2, 0)</span>
<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal)</span>
<span class="sd">        &gt;&gt;&gt; big.spsame(big2)</span>
<span class="sd">        True</span>

<span class="sd">        To retain couplings only from the ``big`` sparse matrix, one should</span>
<span class="sd">        do the following (note the subsequent transposing which ensures hermiticy</span>
<span class="sd">        and is effectively copying couplings from ``big`` to the replaced region.</span>

<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal, scale=(2, 0))</span>
<span class="sd">        &gt;&gt;&gt; big2 = (big2 + big2.transpose()) * 0.5</span>

<span class="sd">        To only retain couplings from the ``minimal`` sparse matrix:</span>

<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal, scale=(0, 2))</span>
<span class="sd">        &gt;&gt;&gt; big2 = (big2 + big2.transpose()) * 0.5</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The current implementation does not preserve the hermiticity of the matrix.</span>
<span class="sd">        If you want to preserve hermiticity of the matrix you have to do the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; sm = (sm + sm.transpose()) / 2</span>

<span class="sd">        Also note that the ordering of the atoms will be ``range(atoms.min()), range(len(other_atoms)), &lt;rest&gt;``.</span>
<span class="sd">        So algorithms using atomic indices should be careful.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like</span>
<span class="sd">            which atoms in `self` that are removed and replaced with ``other.sub(other_atoms)``</span>
<span class="sd">        other : object</span>
<span class="sd">            must be an object of the same type as `self`, a subset is taken from this</span>
<span class="sd">            sparse matrix and combined with `self` to create a new sparse matrix</span>
<span class="sd">        other_atoms : array_like, optional</span>
<span class="sd">            to select a subset of atoms in `other` that are taken out.</span>
<span class="sd">            Defaults to all atoms.</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">            coordinate tolerance to allow a replacement.</span>
<span class="sd">            It is important that this value is smaller than half the distance between</span>
<span class="sd">            the two closests atoms such that there is no ambiguity in selecting</span>
<span class="sd">            equivalent atoms.</span>
<span class="sd">        scale : float or array_like, optional</span>
<span class="sd">            the scale used for the overlapping region. For scalar values it corresponds</span>
<span class="sd">            to passing: ``(scale, scale)``.</span>
<span class="sd">            For array-like input ``scale[0]`` refers to the scale of the matrix elements</span>
<span class="sd">            coupling from `self`, while ``scale[1]`` is the scale of the matrix elements</span>
<span class="sd">            in `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepend : equivalent scheme as this method</span>
<span class="sd">        add : merge two matrices without considering overlap or commensurability</span>
<span class="sd">        transpose : ensure hermiticity by using this routine</span>
<span class="sd">        append : append two sparse matrices</span>
<span class="sd">        Geometry.append</span>
<span class="sd">        Geometry.prepend</span>
<span class="sd">        SparseCSR.scale_columns : method used to scale the two matrix elements values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">           if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>
<span class="sd">        AssertionError</span>
<span class="sd">           if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>


<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        SislWarning</span>
<span class="sd">           in case the overlapping atoms are not comprising the same atomic specie. In some cases this may not be a problem. However, care must be taken by the user if this warning is issued.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a new instance with two sparse matrices merged together by removing and adding</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># here our connection is defined as what is connected to &quot;in&quot;</span>
        <span class="c1"># and what is connected to &quot;out&quot;</span>
        <span class="c1"># Say 0 -&gt; 1</span>
        <span class="c1"># And `atoms` is [0].</span>
        <span class="c1"># Then in = [0], out = [1]</span>
        <span class="c1"># since atoms connect out to [1]</span>

        <span class="c1"># figure out the atoms that needs replacement</span>
        <span class="k">def</span> <span class="nf">get_reduced_system</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; convert the geometry in `sp` to only atoms `atoms` and return the following:</span>

<span class="sd">            1. atoms (sanitized and no order change)</span>
<span class="sd">            2. orbitals (ordered as `atoms`</span>
<span class="sd">            3. the atoms that are connected to OUT and IN</span>
<span class="sd">            4. the orbitals that are connected to OUT and IN</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.replace requires a unique set of atoms&quot;</span><span class="p">)</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">other_orbs</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">ouc2sc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">orbs</span><span class="p">))</span>

            <span class="c1"># Find the orbitals that these atoms connect to such that we can compare</span>
            <span class="c1"># atomic coordinates</span>
            <span class="n">out_connect_orb_sc</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">orbs</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">orbs</span><span class="p">)</span>
            <span class="n">out_connect_orb</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">out_connect_orb_sc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">out_connect_atom_sc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">out_connect_orb_sc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">out_connect_atom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">out_connect_atom_sc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="c1"># figure out connecting back</span>
            <span class="n">atoms_orbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">in_connect_atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">in_connect_orb</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">atom_orbs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_orbs</span><span class="p">):</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">atom_orbs</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">orbs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">out_connect_orb_sc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">in_connect_atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">in_connect_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_orbs</span><span class="p">)</span>

            <span class="n">in_connect_atom</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">)</span>
            <span class="n">in_connect_orb</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">)</span>

            <span class="c1"># create the connection tables</span>
            <span class="n">atom_uc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">,</span> <span class="n">out_connect_atom</span><span class="p">)</span>
            <span class="n">atom_sc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">,</span> <span class="n">out_connect_atom_sc</span><span class="p">)</span>
            <span class="n">orb_uc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">,</span> <span class="n">out_connect_orb</span><span class="p">)</span>
            <span class="n">orb_sc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">,</span> <span class="n">out_connect_orb_sc</span><span class="p">)</span>
            <span class="n">atom_connect</span> <span class="o">=</span> <span class="n">UCSC</span><span class="p">(</span><span class="n">atom_uc</span><span class="p">,</span> <span class="n">atom_sc</span><span class="p">)</span>
            <span class="n">orb_connect</span> <span class="o">=</span> <span class="n">UCSC</span><span class="p">(</span><span class="n">orb_uc</span><span class="p">,</span> <span class="n">orb_sc</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">Info</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">atom_connect</span><span class="p">,</span> <span class="n">orb_connect</span><span class="p">)</span>

        <span class="n">UCSC</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;UCSC&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;uc&quot;</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">])</span>
        <span class="n">Connect</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Connect&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">])</span>
        <span class="n">Info</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Info&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="s2">&quot;orbitals&quot;</span><span class="p">,</span> <span class="s2">&quot;atom_connect&quot;</span><span class="p">,</span> <span class="s2">&quot;orb_connect&quot;</span><span class="p">])</span>

        <span class="n">sgeom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">s_info</span> <span class="o">=</span> <span class="n">get_reduced_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atoms</span> <span class="c1"># sanitized (no order change)</span>

        <span class="n">ogeom</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">o_info</span> <span class="o">=</span> <span class="n">get_reduced_system</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">other_atoms</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atoms</span> <span class="c1"># sanitized (no order change)</span>

        <span class="c1"># Get overlapping atoms by their offset</span>
        <span class="c1"># We need to get a 1-1 correspondance between the two connecting geometries</span>
        <span class="c1"># For instance `self` may be ordered differently than `other`.</span>
        <span class="c1"># So we need to figure out how the atoms are arranged in *both* regions.</span>
        <span class="c1"># This is where `eps` comes into play since we have to ensure that the</span>
        <span class="c1"># connecting regions are within some given tolerance.</span>

        <span class="k">def</span> <span class="nf">create_geometry</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Create the supercell geometry with coordinates as given &quot;&quot;&quot;</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">uc_atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">uc_atoms</span><span class="p">])</span>

        <span class="c1"># We know that the *IN* connections are in the primary unit-cell</span>
        <span class="c1"># so we don&#39;t need to handle supercell information</span>
        <span class="c1"># Atoms *inside* the replacement region that couples out</span>
        <span class="n">sgeom_in</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>
        <span class="n">ogeom_in</span> <span class="o">=</span> <span class="n">ogeom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>
        <span class="n">soverlap_in</span><span class="p">,</span> <span class="n">ooverlap_in</span> <span class="o">=</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">ogeom_in</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                                    <span class="n">offset</span><span class="o">=-</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                                    <span class="n">offset_other</span><span class="o">=-</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Not replacement region, i.e. the IN (above) atoms are connecting to</span>
        <span class="c1"># these atoms:</span>
        <span class="n">sgeom_out</span> <span class="o">=</span> <span class="n">create_geometry</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
        <span class="n">ogeom_out</span> <span class="o">=</span> <span class="n">create_geometry</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
        <span class="n">soverlap_out</span><span class="p">,</span> <span class="n">ooverlap_out</span> <span class="o">=</span> <span class="n">sgeom_out</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">ogeom_out</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                                       <span class="n">offset</span><span class="o">=-</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                                       <span class="n">offset_other</span><span class="o">=-</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># trigger for errors</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Now we have the different geometries around to handle how the merging</span>
        <span class="c1"># process.</span>
        <span class="c1"># Before proceeding we will check whether the dimensions match.</span>
        <span class="c1"># I.e. checking that the orbitals connecting in/out are the same is important.</span>

        <span class="c1">#print(&quot;in:&quot;)</span>
        <span class="c1">#print(s_info.atom_connect.uc.IN)</span>
        <span class="c1">#print(soverlap_in)</span>
        <span class="c1">#print(o_info.atom_connect.uc.IN)</span>
        <span class="c1">#print(ooverlap_in)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sgeom_in</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">soverlap_in</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">ogeom_in</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ooverlap_in</span><span class="p">)):</span>

            <span class="c1"># figure out which atoms are not connecting</span>
            <span class="n">s_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                     <span class="n">soverlap_in</span><span class="p">)</span>
            <span class="n">o_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                     <span class="n">ooverlap_in</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">The number of atoms in the replacement region that connects to the surrounding</span>
<span class="s2">atoms are not the same in &#39;self&#39; and &#39;other&#39;.</span>
<span class="s2">This means that the number of connections is not the same. Please ensure this.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">self: atoms not matched in &#39;other&#39;: </span><span class="si">{</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">s_diff</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">other: atoms not matched in &#39;self&#39;: </span><span class="si">{</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">o_diff</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">],</span>
                             <span class="n">ogeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">Atoms in the replacement region have different number of orbitals on the atoms</span>
<span class="s2">that lie at the border.</span>

<span class="s2">self orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]</span><span class="si">}</span><span class="s2"></span>
<span class="s2">other orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="c1">#print(&quot;out:&quot;)</span>
        <span class="c1">#print(s_info.atom_connect.uc.OUT)</span>
        <span class="c1">#print(soverlap_out)</span>
        <span class="c1">#print(o_info.atom_connect.uc.OUT)</span>
        <span class="c1">#print(ooverlap_out)</span>

        <span class="c1"># [so]overlap_out are now in the order of [so]_info.atom_connect.out</span>
        <span class="c1"># so we still have to convert them to proper indices if used</span>
        <span class="c1"># We cannot really check the soverlap_out == len(sgeom_out)</span>
        <span class="c1"># in case we have a replaced sparse matrix in the middle of another bigger</span>
        <span class="c1"># sparse matrix.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sgeom_out</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">soverlap_out</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">ogeom_out</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ooverlap_out</span><span class="p">)):</span>

            <span class="c1"># figure out which atoms are not connecting</span>
            <span class="n">s_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                     <span class="n">soverlap_out</span><span class="p">)</span>
            <span class="n">o_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
                                     <span class="n">ooverlap_out</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">Number of atoms connecting to the replacement region are not the same in &#39;self&#39; and &#39;other&#39;.</span>
<span class="s2">Please ensure this.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">self: atoms (in supercell) connecting to &#39;atoms&#39; not matched in &#39;other&#39;: </span><span class="si">{</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">[</span><span class="n">s_diff</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">other: atoms (in supercell) connecting to &#39;other_atoms&#39; not matched in &#39;self&#39;: </span><span class="si">{</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">[</span><span class="n">o_diff</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_out</span><span class="p">],</span>
                             <span class="n">ogeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_out</span><span class="p">]):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">Atoms in the connection region have different number of orbitals on the atoms.</span>

<span class="s2">self orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_out</span><span class="p">]</span><span class="si">}</span><span class="s2"></span>
<span class="s2">other orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_out</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="c1"># we can only ensure the orbitals that connect *out* have the same count</span>
        <span class="c1"># For supercell connections hopping *IN* might be different due to the supercell</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">orb_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">orb_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2"></span>

<span class="s2">Number of orbitals connecting to replacement region is not consistent</span>
<span class="s2">between &#39;self&#39; and &#39;other&#39;.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">warn_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">S_</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span>
        <span class="n">O_</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span>
        <span class="k">for</span> <span class="n">s_</span><span class="p">,</span> <span class="n">o_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soverlap_in</span><span class="p">,</span> <span class="n">ooverlap_in</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ogeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]:</span>
                <span class="n">warn_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Atom &#39;self[</span><span class="si">{</span><span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39; is not equivalent to &#39;other[</span><span class="si">{</span><span class="n">O_</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39;:</span>
<span class="s2">  </span><span class="si">{</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">  !=  </span><span class="si">{</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">warn_msg</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Inequivalent atoms found in replacement region, this may or may not be a problem</span>
<span class="s2">depending on your use case. Please be careful though.</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="n">warn_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">S_</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">O_</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">checked1d</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">s_</span><span class="p">,</span> <span class="n">o_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soverlap_out</span><span class="p">,</span> <span class="n">ooverlap_out</span><span class="p">):</span>
            <span class="n">uc_s_</span> <span class="o">=</span> <span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
            <span class="k">if</span> <span class="n">sgeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ogeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span> <span class="ow">and</span> <span class="n">checked1d</span><span class="p">[</span><span class="n">uc_s_</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">checked1d</span><span class="p">[</span><span class="n">uc_s_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">warn_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Atom &#39;self[</span><span class="si">{</span><span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39; is not equivalent to &#39;other[</span><span class="si">{</span><span class="n">O_</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39;:</span>
<span class="s2">  </span><span class="si">{</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">  !=  </span><span class="si">{</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">warn_msg</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Inequivalent atoms found in connection region, this may or may not be a problem</span>
<span class="s2">depending on your use case. Note indices in the following are supercell indices. Please be careful though.</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># clean-up to make it clear that we are not going to use them.</span>
        <span class="k">del</span> <span class="n">sgeom_out</span><span class="p">,</span> <span class="n">ogeom_out</span>

        <span class="c1"># this is where other.sub(other_atoms) gets inserted</span>
        <span class="n">ainsert_idx</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">oinsert_idx</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">ainsert_idx</span><span class="p">)</span>
        <span class="c1"># this is the indices of the new atoms in the new geometry</span>
        <span class="n">self_other_atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ainsert_idx</span><span class="p">,</span> <span class="n">ainsert_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">))</span>

        <span class="c1"># We need to do the replacement in two steps</span>
        <span class="c1"># A. the geometry</span>
        <span class="c1">#    This will insert other at ainsert_idx</span>
        <span class="c1">#    Note that sub(other_atoms) re-arranges the atoms correctly</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ogeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
        <span class="c1"># this will perhaps re-order atoms from other_atoms</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">sgeom_in</span><span class="p">,</span> <span class="n">ogeom_in</span>
        <span class="c1"># A. DONE</span>

        <span class="c1"># B. Merge the two sparse patterns</span>
        <span class="n">scsr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">col</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="c1"># helper function</span>

        <span class="k">def</span> <span class="nf">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">ouc2sc</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Our first task is to merge the two sparse patterns.</span>
        <span class="c1"># Delete the *old* values</span>
        <span class="c1"># To ensure that inserting will not leave *empty* values</span>
        <span class="c1"># we first reduce arrays so that the ptr array is not needed</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">scsr</span><span class="o">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Do the same reduction for the inserted values</span>
        <span class="n">ocsr</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ocsr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ocsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">])</span>
        <span class="c1"># we offset the new columns by self.shape[1], in this way we know</span>
        <span class="c1"># which couplings belong to the inserted and the original csr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[:</span><span class="n">oinsert_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[:</span><span class="n">oinsert_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">oinsert_idx</span><span class="p">,</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">])</span>

        <span class="c1"># Create the sparse pattern</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">D</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)),</span>
                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">+</span> <span class="n">ogeom</span><span class="o">.</span><span class="n">no_s</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">del</span> <span class="n">D</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ncol</span>

        <span class="c1"># Now we have merged the two sparse patterns</span>
        <span class="c1"># But we need to correct the orbital couplings</span>
        <span class="c1"># : *outside* refers to the original sparse pattern (without `atoms`)</span>
        <span class="c1"># : *inside* refers to the inserted sparse pattern (other.sub(other_atoms))</span>
        <span class="c1"># We have to do 1 and 2 simultaneously.</span>
        <span class="c1"># We have to do 3 and 4 simultaneously.</span>
        <span class="c1"># This is because they may have overlapping columns</span>

        <span class="c1"># 1: couplings from *outside* to *outside* (no scale)</span>
        <span class="c1"># 2: couplings from *outside* to *inside* (scaled)</span>
        <span class="c1"># 3: couplings from *inside* to *inside* (no scale)</span>
        <span class="c1"># 4: couplings from *inside* to *outside* (scaled)</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
        <span class="n">conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span>

        <span class="k">def</span> <span class="nf">assert_unique</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">conc</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">conc</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span>

        <span class="c1"># 1:</span>
        <span class="c1">#print(&quot;1:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sgeom</span><span class="p">)),</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="n">new</span><span class="p">[</span><span class="n">ainsert_idx</span><span class="p">:]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 2:</span>
        <span class="c1">#print(&quot;2:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]</span>
        <span class="c1"># algorithm to get indices in other_atoms</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">tmp</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ainsert_idx</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># translate columns</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="o">*</span><span class="n">assert_unique</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
        <span class="c1"># scale columns that connects inside</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>

        <span class="c1"># on to the *inside* 3, 4</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>

        <span class="c1"># 3:</span>
        <span class="c1">#print(&quot;3:&quot;)</span>
        <span class="c1"># we have all the *inside* column indices offset by self.shape[1]</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">other_atoms</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">ainsert_idx</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">))</span>
        <span class="c1">#print(&quot;old: &quot;, old)</span>
        <span class="c1">#print(&quot;new: &quot;, new)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 4:</span>
        <span class="c1">#print(&quot;4:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ogeom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;More than 1 atom </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> for atom </span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">ogeom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(&quot;old: &quot;, old)</span>
        <span class="c1">#print(&quot;new: &quot;, new)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># translate columns</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="o">*</span><span class="n">assert_unique</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
        <span class="c1"># scale columns that connects inside</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>

        <span class="c1"># ensure we have translated all columns correctly</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">((</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># correct shape of column matrix</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">csr</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="SparseOrbital.toSparseAtom"><a class="viewcode-back" href="../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.toSparseAtom">[docs]</a>    <span class="k">def</span> <span class="nf">toSparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</span>

<span class="sd">        This converts the orbital sparse pattern to an atomic sparse pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, optional</span>
<span class="sd">           number of dimensions allocated in the SparseAtom object, default to the same</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           used data-type for the sparse object. Defaults to the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Create a conversion vector</span>
        <span class="n">orb2atom</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)),</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orb2atom</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># First convert all rows to the same</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Now build the new sparse pattern</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>

            <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">([</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Get current atomic elements</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">])</span>

            <span class="c1"># These are now the atomic columns</span>
            <span class="c1"># Immediately reduce to unique elements</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">orb2atom</span><span class="p">[</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>

            <span class="c1"># Step counters</span>
            <span class="n">col</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">acol</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">acol</span><span class="p">)</span>

        <span class="c1"># Now we can create the sparse atomic</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">spAtom</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:]</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># unique returns sorted elements</span>
        <span class="k">return</span> <span class="n">spAtom</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2022, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>