<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl_toolbox.btd._btd &mdash; sisl 0.1-b0feb0c</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=87e54e7c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=81cd38e2"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../../_static/tabs.js?v=3ee01567"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
              <div class="version">
                0.1-b0feb0c
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/viz_module/index.html"><code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/ase/index.html">ASE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development details</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Similar solutions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl_toolbox.btd._btd</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl_toolbox.btd._btd</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="sd">&quot;&quot;&quot; Eigenchannel calculator for any number of electrodes</span>

<span class="sd">Developer: Nick Papior</span>
<span class="sd">Contact: nickpapior &lt;at&gt; gmail.com</span>
<span class="sd">sisl-version: &gt;=0.11.0</span>
<span class="sd">tbtrans-version: &gt;=siesta-4.1.5</span>

<span class="sd">This eigenchannel calculater uses TBtrans output to calculate the eigenchannels</span>
<span class="sd">for N-terminal systems. In the future this will get transferred to the TBtrans code</span>
<span class="sd">but for now this may be used for arbitrary geometries.</span>

<span class="sd">It requires two inputs and has several optional flags.</span>

<span class="sd">- The siesta.TBT.nc file which contains the geometry that is to be calculated for</span>
<span class="sd">  The reason for using the siesta.TBT.nc file is the ease of use:</span>

<span class="sd">    The siesta.TBT.nc contains electrode atoms and device atoms. Hence it</span>
<span class="sd">    becomes easy to read in the electrode atomic positions.</span>
<span class="sd">    Note that since you&#39;ll always do a 0 V calculation this isn&#39;t making</span>
<span class="sd">    any implications for the requirement of the TBT.nc file.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">ssp</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">svds</span>

<span class="kn">import</span> <span class="nn">sisl</span> <span class="k">as</span> <span class="nn">si</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="kn">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span> <span class="nn">sisl.linalg</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">cholesky</span><span class="p">,</span>
    <span class="n">eigh</span><span class="p">,</span>
    <span class="n">eigh_destroy</span><span class="p">,</span>
    <span class="n">inv_destroy</span><span class="p">,</span>
    <span class="n">signsqrt</span><span class="p">,</span>
    <span class="n">solve</span><span class="p">,</span>
    <span class="n">svd_destroy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">sisl.utils.misc</span> <span class="kn">import</span> <span class="n">PropertyDict</span>

<span class="n">arangei</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span>
<span class="n">indices_only</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">indices_only</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">indices</span>
<span class="n">conj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;PivotSelfEnergy&quot;</span><span class="p">,</span> <span class="s2">&quot;DownfoldSelfEnergy&quot;</span><span class="p">,</span> <span class="s2">&quot;DeviceGreen&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">dagger</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">conj</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculating the SVD of matrix A for the scattering state</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.ndarray</span>
<span class="sd">       matrix to obtain SVD from</span>
<span class="sd">    scale : bool or float, optional</span>
<span class="sd">       whether to scale matrix `A` to be above ``1e-12`` or by a user-defined number</span>
<span class="sd">    lapack_driver : str, optional</span>
<span class="sd">       driver queried from `scipy.linalg.svd`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Scale matrix by a factor to lie in [1e-12; inf[</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">12</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">12</span> <span class="o">-</span> <span class="n">_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">*=</span> <span class="n">scale</span>

    <span class="c1"># Numerous accounts of SVD algorithms using gesdd results</span>
    <span class="c1"># in poor results when min(M, N) &gt;= 26 (block size).</span>
    <span class="c1"># This may be an error in the D&amp;C algorithm.</span>
    <span class="c1"># Here we resort to precision over time, but user may decide.</span>
    <span class="n">driver</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;driver&quot;</span><span class="p">,</span> <span class="s2">&quot;gesvd&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">driver</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;arpack&quot;</span><span class="p">,</span> <span class="s2">&quot;lobpcg&quot;</span><span class="p">,</span> <span class="s2">&quot;sparse&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;sparse&quot;</span><span class="p">:</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="s2">&quot;arpack&quot;</span>  <span class="c1"># scipy default</span>

        <span class="c1"># filter out keys for scipy.sparse.svds</span>
        <span class="n">svds_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;ncv&quot;</span><span class="p">,</span> <span class="s2">&quot;tol&quot;</span><span class="p">,</span> <span class="s2">&quot;v0&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="p">}</span>
        <span class="c1"># do not calculate vt</span>
        <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;return_singular_vectors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span>
        <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;solver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver</span>
        <span class="k">if</span> <span class="s2">&quot;k&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">svds_kwargs</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">svds_kwargs</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># it must be a lapack driver:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">svd_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lapack_driver</span><span class="o">=</span><span class="n">driver</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">_</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="n">scale</span>

    <span class="c1"># A note of caution.</span>
    <span class="c1"># The DOS values are not actual DOS values.</span>
    <span class="c1"># In fact the DOS should be calculated as:</span>
    <span class="c1">#   DOS * &lt;i| S(k) |i&gt;</span>
    <span class="c1"># to account for the overlap matrix. For orthogonal basis sets</span>
    <span class="c1"># this DOS eigenvalue is correct.</span>
    <span class="k">return</span> <span class="n">DOS</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">A</span>


<div class="viewcode-block" id="PivotSelfEnergy">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.PivotSelfEnergy.html#sisl_toolbox.btd.PivotSelfEnergy">[docs]</a>
<span class="k">class</span> <span class="nc">PivotSelfEnergy</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">SelfEnergy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for the self-energy object</span>

<span class="sd">    This may either be a `tbtsencSileTBtrans`, a `tbtgfSileTBtrans` or a sisl.SelfEnergy objectfile</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PivotSelfEnergy.__init__">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.PivotSelfEnergy.html#sisl_toolbox.btd.PivotSelfEnergy.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Name of electrode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># File containing the self-energy</span>
        <span class="c1"># This may be either of:</span>
        <span class="c1">#  tbtsencSileTBtrans</span>
        <span class="c1">#  tbtgfSileTBtrans</span>
        <span class="c1">#  SelfEnergy object (for direct calculation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_se</span> <span class="o">=</span> <span class="n">se</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tbtrans</span><span class="o">.</span><span class="n">tbtsencSileTBtrans</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">se_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">broad_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">broadening_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">se_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">broad_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">broadening_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Store the pivoting for faster indexing</span>
        <span class="k">if</span> <span class="n">pivot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tbtrans</span><span class="o">.</span><span class="n">tbtsencSileTBtrans</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must be passed a sisl.io.tbtrans.tbtsencSileTBtrans. &quot;</span>
                    <span class="s2">&quot;Otherwise use the DownfoldSelfEnergy method with appropriate arguments.&quot;</span>
                <span class="p">)</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">se</span>

        <span class="c1"># Pivoting indices for the self-energy for the device region</span>
        <span class="c1"># but with respect to the full system size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Pivoting indices for the self-energy for the device region</span>
        <span class="c1"># but with respect to the device region only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvt_dev</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">in_device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># the pivoting in the downfolding region (with respect to the full</span>
        <span class="c1"># system size)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvt_down</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">pivot_down</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Retrieve BTD matrices for the corresponding electrode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">btd</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Get the individual matrices</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">pvt_btd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cbtd</span><span class="p">:</span>
            <span class="c1"># collect the pivoting indices for the downfolding</span>
            <span class="n">pvt_btd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt_down</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">o</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="c1"># self.pvt_btd = np.concatenate(pvt_btd).reshape(-1, 1)</span>
        <span class="c1"># self.pvt_btd_sort = arangei(o)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_se_func</span> <span class="o">=</span> <span class="n">se_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_broad_func</span> <span class="o">=</span> <span class="n">broad_func</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">no: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt_dev</span><span class="p">)</span>

<div class="viewcode-block" id="PivotSelfEnergy.self_energy">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.PivotSelfEnergy.html#sisl_toolbox.btd.PivotSelfEnergy.self_energy">[docs]</a>
    <span class="k">def</span> <span class="nf">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="PivotSelfEnergy.broadening_matrix">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.PivotSelfEnergy.html#sisl_toolbox.btd.PivotSelfEnergy.broadening_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">broadening_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broad_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DownfoldSelfEnergy">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DownfoldSelfEnergy.html#sisl_toolbox.btd.DownfoldSelfEnergy">[docs]</a>
<span class="k">class</span> <span class="nc">DownfoldSelfEnergy</span><span class="p">(</span><span class="n">PivotSelfEnergy</span><span class="p">):</span>
<div class="viewcode-block" id="DownfoldSelfEnergy.__init__">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DownfoldSelfEnergy.html#sisl_toolbox.btd.DownfoldSelfEnergy.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">Hdevice</span><span class="p">,</span> <span class="n">eta_device</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bulk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bloch</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">pivot</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">bloch</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">_bloch</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bloch</span> <span class="o">=</span> <span class="n">_bloch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bloch</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Bloch</span><span class="p">(</span><span class="n">bloch</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_eta_device</span> <span class="o">=</span> <span class="n">eta_device</span>

        <span class="c1"># To re-create the downfoldable self-energies we need a few things:</span>
        <span class="c1"># pivot == for pivoting indices and BTD downfolding region</span>
        <span class="c1"># se == SelfEnergy for calculating self-energies and broadening matrix</span>
        <span class="c1"># Hdevice == device H for downfolding the electrode self-energy</span>
        <span class="c1"># bulk == whether the electrode self-energy argument should be passed bulk</span>
        <span class="c1">#         or not</span>
        <span class="c1"># name == just the name</span>

        <span class="c1"># storage data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">bulk</span> <span class="o">=</span> <span class="n">bulk</span>

        <span class="c1"># Retain the device for only the downfold region</span>
        <span class="c1"># a_down is sorted!</span>
        <span class="n">a_elec</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">a_elec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Now figure out all the atoms in the downfolding region</span>
        <span class="c1"># pivot_down is the electrode + all orbitals including the orbitals</span>
        <span class="c1"># reaching into the device</span>
        <span class="n">pivot_down</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">pivot_down</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># note that the last orbitals in pivot_down is the returned self-energies</span>
        <span class="c1"># that we want to calculate in this class</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">geometry</span>
        <span class="c1"># Figure out the full device part of the downfolding region</span>
        <span class="c1"># this will still be sorted</span>
        <span class="n">down_atoms</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">pivot_down</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># this will also be sorted</span>
        <span class="n">down_orbitals</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">down_atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># The orbital indices in self.H.device.geometry</span>
        <span class="c1"># which transfers the orbitals to the downfolding region</span>

        <span class="c1"># Now we need to figure out the pivoting indices from the sub-set</span>
        <span class="c1"># geometry</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">electrode</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">spgeom0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">Hdevice</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">down_atoms</span><span class="p">)</span>
        <span class="c1"># geometry_down = self._data.H.device.geometry</span>

        <span class="c1"># Now we retain the positions of the electrode orbitals in the</span>
        <span class="c1"># non pivoted structure for inserting the self-energy</span>
        <span class="c1"># Once the down-folded matrix is formed we can pivot it</span>
        <span class="c1"># in the BTD class</span>
        <span class="c1"># The self-energy is inserted in the non-pivoted matrix</span>
        <span class="n">o_elec</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">a_elec</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pvt</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">down_orbitals</span><span class="p">,</span> <span class="n">o_elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">elec</span> <span class="o">=</span> <span class="n">pvt</span><span class="p">[</span><span class="n">pvt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pvt</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">down_orbitals</span><span class="p">,</span> <span class="n">pivot_down</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pvt</span><span class="p">[</span><span class="n">pvt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create BTD indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">cumbtd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">eta</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">se</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">no: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, blocks: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span><span class="si">}</span><span class="s2">, eta: </span><span class="si">{</span><span class="n">eta</span><span class="si">}</span><span class="s2">, eta_device: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_eta_device</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">se</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dev</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_Ek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="c1"># we have already prepared the calculation</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ed</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Eb</span> <span class="o">=</span> <span class="n">E</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ed</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_device</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Eb</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_se</span><span class="o">.</span><span class="n">eta</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Prepare the matrices</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">H</span>

        <span class="n">Ed</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Ed</span>
        <span class="n">Eb</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Eb</span>
        <span class="n">data</span><span class="o">.</span><span class="n">SeH</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ed</span> <span class="o">-</span> <span class="n">H</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">bulk</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">hsk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># constructor for the H and S part</span>
                <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">electrode</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">Eb</span> <span class="o">-</span> <span class="n">H</span><span class="o">.</span><span class="n">electrode</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">SeH</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">elec</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bloch</span><span class="p">(</span>
                <span class="n">hsk</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
            <span class="p">)</span>

<div class="viewcode-block" id="DownfoldSelfEnergy.self_energy">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DownfoldSelfEnergy.html#sisl_toolbox.btd.DownfoldSelfEnergy.self_energy">[docs]</a>
    <span class="k">def</span> <span class="nf">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bloch</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">self_energy</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now put it in the matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">SeH</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">M</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">elec</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">elec</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">-=</span> <span class="n">se</span>

        <span class="c1"># transfer to BTD</span>
        <span class="n">pvt</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dev</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">cumbtd</span>

        <span class="k">def</span> <span class="nf">gM</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">M</span><span class="p">[</span><span class="n">pvt</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="n">pvt</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="n">Mr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)):</span>
            <span class="n">sli1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">Mr</span> <span class="o">=</span> <span class="n">gM</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">sli1</span><span class="p">,</span> <span class="n">sli</span><span class="p">)</span> <span class="o">@</span> <span class="n">solve</span><span class="p">(</span>
                <span class="n">gM</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">sli</span><span class="p">,</span> <span class="n">sli</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mr</span><span class="p">,</span>
                <span class="n">gM</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">sli</span><span class="p">,</span> <span class="n">sli1</span><span class="p">),</span>
                <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sli</span> <span class="o">=</span> <span class="n">sli1</span>

        <span class="k">return</span> <span class="n">Mr</span></div>


<div class="viewcode-block" id="DownfoldSelfEnergy.broadening_matrix">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DownfoldSelfEnergy.html#sisl_toolbox.btd.DownfoldSelfEnergy.broadening_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">broadening_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">se2broadening</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>
</div>



<span class="k">class</span> <span class="nc">BlockMatrixIndexer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bm</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span> <span class="o">=</span> <span class="n">bm</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loop contained indices in the BlockMatrix&quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> index deletion must be done with a tuple.&quot;</span>
            <span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> index checking must be done with a tuple.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">_M</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> index retrieval must be done with a tuple.&quot;</span>
            <span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">_M</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">key</span>
            <span class="c1"># the data-type is probably incorrect.. :(</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">M</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> index setting must be done with a tuple.&quot;</span>
            <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">M</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">s</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Could not assign matrix of shape </span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> into matrix of shape </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bm</span><span class="o">.</span><span class="n">_M</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>


<span class="k">class</span> <span class="nc">BlockMatrix</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container class that holds a block matrix&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_M</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">blocks</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span>

    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="c1"># stack stuff together</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">BI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">)],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">tobtd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return only the block tridiagonal part of the matrix&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">sBI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">rBI</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sBI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                <span class="n">rBI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sBI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">tobd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return only the block diagonal part of the matrix&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">sBI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">rBI</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sBI</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="n">rBI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sBI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">))])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">block_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BlockMatrixIndexer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="DeviceGreen">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen">[docs]</a>
<span class="k">class</span> <span class="nc">DeviceGreen</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Block-tri-diagonal Green function calculator</span>

<span class="sd">    This class enables the extraction and calculation of some important</span>
<span class="sd">    quantities not currently accessible in TBtrans.</span>

<span class="sd">    For instance it may be used to calculate scattering states from</span>
<span class="sd">    the Green function.</span>
<span class="sd">    Once scattering states have been calculated one may also calculate</span>
<span class="sd">    the eigenchannels.</span>

<span class="sd">    Both calculations are very efficient and uses very little memory</span>
<span class="sd">    compared to the full matrices normally used.</span>

<span class="sd">    Consider a regular 2 electrode setup with transport direction</span>
<span class="sd">    along the 3rd lattice vector. Then the following example may</span>
<span class="sd">    be used to calculate the eigen-channels:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       import sisl</span>
<span class="sd">       from sisl_toolbox.btd import *</span>
<span class="sd">       # First read in the required data</span>
<span class="sd">       H_elec = sisl.Hamiltonian.read(&quot;ELECTRODE.nc&quot;)</span>
<span class="sd">       H = sisl.Hamiltonian.read(&quot;DEVICE.nc&quot;)</span>
<span class="sd">       # remove couplings along the self-energy direction</span>
<span class="sd">       # to ensure no fake couplings.</span>
<span class="sd">       H.set_nsc(c=1)</span>

<span class="sd">       # Read in a single tbtrans output which contains the BTD matrices</span>
<span class="sd">       # and instructs this class how it should pivot the matrix to obtain</span>
<span class="sd">       # a BTD matrix.</span>
<span class="sd">       tbt = sisl.get_sile(&quot;siesta.TBT.nc&quot;)</span>

<span class="sd">       # Define the self-energy calculators which will downfold the</span>
<span class="sd">       # self-energies into the device region.</span>
<span class="sd">       # Since a downfolding will be done it requires the device Hamiltonian.</span>
<span class="sd">       H_elec.shift(tbt.mu(&quot;Left&quot;))</span>
<span class="sd">       left = DownfoldSelfEnergy(&quot;Left&quot;, s.RecursiveSI(H_elec, &quot;-C&quot;, eta=tbt.eta(&quot;Left&quot;),</span>
<span class="sd">                                 tbt, H)</span>
<span class="sd">       H_elec.shift(tbt.mu(&quot;Right&quot;) - tbt.mu(&quot;Left&quot;))</span>
<span class="sd">       left = DownfoldSelfEnergy(&quot;Right&quot;, s.RecursiveSI(H_elec, &quot;+C&quot;, eta=tbt.eta(&quot;Right&quot;),</span>
<span class="sd">                                 tbt, H)</span>

<span class="sd">       G = DeviceGreen(H, [left, right], tbt)</span>

<span class="sd">       # Calculate the scattering state from the left electrode</span>
<span class="sd">       # and then the eigen channels to the right electrode</span>
<span class="sd">       state = G.scattering_state(&quot;Left&quot;, E=0.1)</span>
<span class="sd">       eig_channel = G.eigenchannel(state, &quot;Right&quot;)</span>

<span class="sd">    To make this easier there exists a short-hand version that does the</span>
<span class="sd">    above:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       G = DeviceGreen.from_fdf(&quot;RUN.fdf&quot;)</span>

<span class="sd">    which reads all variables from the FDF file and parses them accordingly.</span>
<span class="sd">    This does not take all things into consideration, but should cover most problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO we should speed this up by overwriting A with the inverse once</span>
    <span class="c1">#      calculated. We don&#39;t need it at that point.</span>
    <span class="c1">#      That would probably require us to use a method to retrieve</span>
    <span class="c1">#      the elements which determines if it has been calculated or not.</span>

<div class="viewcode-block" id="DeviceGreen.__init__">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">elecs</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create Green function with Hamiltonian and BTD matrix elements&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>

        <span class="c1"># Store electrodes (for easy retrieval of the SE)</span>
        <span class="c1"># There may be no electrodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span> <span class="o">=</span> <span class="n">elecs</span>
        <span class="c1"># self.elecs_pvt = [pivot.pivot(el.name).reshape(-1, 1)</span>
        <span class="c1">#                  for el in elecs]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pivot</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">el</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">in_device</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elecs</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">pivot</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">.</span><span class="n">btd</span><span class="p">()</span>

        <span class="c1"># global device eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="c1"># Create BTD indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">no: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, blocks: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span><span class="si">}</span><span class="s2">, eta: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">elec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="DeviceGreen.from_fdf">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.from_fdf">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fdf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fdf</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;TBT&quot;</span><span class="p">,</span> <span class="n">use_tbt_se</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new `DeviceGreen` using information gathered from the fdf</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fdf : str or fdfSileSiesta</span>
<span class="sd">           fdf file to read the parameters from</span>
<span class="sd">        prefix : {&quot;TBT&quot;, &quot;TS&quot;}</span>
<span class="sd">           which prefix to use, if TBT it will prefer TBT prefix, but fall back</span>
<span class="sd">           to TS prefixes.</span>
<span class="sd">           If TS, only these prefixes will be used.</span>
<span class="sd">        use_tbt_se : bool, optional</span>
<span class="sd">           whether to use the TBT.SE.nc files for self-energies</span>
<span class="sd">           or calculate them on the fly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fdf</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">fdf</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">siesta</span><span class="o">.</span><span class="n">fdfSileSiesta</span><span class="p">(</span><span class="n">fdf</span><span class="p">)</span>

        <span class="c1"># Now read the values needed</span>
        <span class="n">slabel</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SystemLabel&quot;</span><span class="p">,</span> <span class="s2">&quot;siesta&quot;</span><span class="p">)</span>
        <span class="c1"># Test if the TBT output file exists:</span>
        <span class="n">tbt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;TBT.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT_UP.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT_DN.nc&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                <span class="n">tbt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">tbt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not find file </span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.[TBT|TBT_UP|TBT_DN].nc&quot;</span>
            <span class="p">)</span>
        <span class="n">tbt</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">tbt</span><span class="p">)</span>
        <span class="n">is_tbtrans</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;TBT&quot;</span>

        <span class="c1"># Read the device H, only valid for TBT stuff</span>
        <span class="n">Hdev</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.HS&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TSHS&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">get_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parse lines in the %block constructs of fdf&#39;s&quot;&quot;&quot;</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">read_electrode</span><span class="p">(</span><span class="n">elec_prefix</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parse the electrode information and return a dictionary with content&quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">sisl.unit.siesta</span> <span class="kn">import</span> <span class="n">unit_convert</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tbt.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">ret</span>
                    <span class="n">ret</span><span class="p">,</span> <span class="n">un</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_convert</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">ret</span>
                    <span class="n">ret</span><span class="p">,</span> <span class="n">un</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_convert</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="n">tbt_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;TBT.</span><span class="si">{</span><span class="n">elec_prefix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">ts_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;TS.</span><span class="si">{</span><span class="n">elec_prefix</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">block</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">Helec</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">.HS&quot;</span><span class="p">)</span>
            <span class="n">bulk</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TS.Elecs.Bulk&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TS.Elecs.Eta&quot;</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="n">bloch</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">.Bloch.A</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">.HS&quot;</span><span class="p">,</span> <span class="n">Helec</span><span class="p">)</span>
                <span class="n">bulk</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.Elecs.Bulk&quot;</span><span class="p">,</span> <span class="n">bulk</span><span class="p">)</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.Elecs.Eta&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">.Bloch.A</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Convert to key value based function</span>
            <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">get_line</span><span class="p">,</span> <span class="n">block</span><span class="p">)}</span>

            <span class="c1"># Retrieve data</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;hs&quot;</span><span class="p">,</span> <span class="s2">&quot;hs-file&quot;</span><span class="p">,</span> <span class="s2">&quot;tshs&quot;</span><span class="p">,</span> <span class="s2">&quot;tshs-file&quot;</span><span class="p">):</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">Helec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Helec</span><span class="p">:</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">Helec</span><span class="p">)</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could not find &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;electrode HS in block: </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> ??&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Get semi-infinite direction</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-direction&quot;</span><span class="p">,</span> <span class="s2">&quot;-dir&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;semi-inf</span><span class="si">{</span><span class="n">suf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">semi_inf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">semi_inf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could not find &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;electrode semi-inf-direction in block: </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> ??&quot;</span>
                <span class="p">)</span>
            <span class="c1"># convert to sisl infinite</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">{</span><span class="s2">&quot;a1&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a2&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a3&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">semi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">semi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Check that semi_inf is a recursive one!</span>
            <span class="k">if</span> <span class="n">semi_inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span> <span class="s2">&quot;+a&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="s2">&quot;+b&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;+c&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not implement other &quot;</span>
                    <span class="s2">&quot;self energies than the recursive one.&quot;</span>
                <span class="p">)</span>

            <span class="n">bulk</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;bulk&quot;</span><span class="p">,</span> <span class="n">bulk</span><span class="p">))</span>
            <span class="c1"># loop for 0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sufs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a1&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;a3&quot;</span><span class="p">)]):</span>
                <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="n">sufs</span><span class="p">:</span>
                    <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;bloch-</span><span class="si">{</span><span class="n">suf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">bloch</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">block_get</span><span class="p">(</span>
                    <span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;bloch&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="n">ret</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;eta&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="c1"># manual shift of the fermi-level</span>
            <span class="n">dEf</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;delta-Ef&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="c1"># shift electronic structure here, we store it in the returned</span>
            <span class="c1"># dictionary, for information, but it shouldn&#39;t be used.</span>
            <span class="n">Helec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">dEf</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">dEf</span> <span class="o">=</span> <span class="n">dEf</span>
            <span class="c1"># add a fraction of the bias in the coupling elements of the</span>
            <span class="c1"># E-C region, only meaningful for</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">V_fraction</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;V-fraction&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">V_fraction</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found a non-zero V-fraction value. &quot;</span>
                    <span class="s2">&quot;This is currently not implemented.&quot;</span>
                <span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">Helec</span> <span class="o">=</span> <span class="n">Helec</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">bloch</span> <span class="o">=</span> <span class="n">bloch</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">bulk</span> <span class="o">=</span> <span class="n">bulk</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># Loop electrodes and read in and construct data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_tbt_se</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_tbt_se</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="p">[</span><span class="n">use_tbt_se</span><span class="p">]</span>

        <span class="n">elec_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">eta_dev</span> <span class="o">=</span> <span class="mf">1e123</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="c1"># read from the block</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">read_electrode</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Elec.</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">elec_data</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c1"># read from the TBT file (to check if the user has changed the input file)</span>
            <span class="n">elec_eta</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">elec_eta</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found inconsistent &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;imaginary eta from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">eta</span><span class="si">}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2"> eV&quot;</span>
                <span class="p">)</span>

            <span class="n">bloch</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">bloch</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">bloch</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found inconsistent &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Bloch expansions from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">bloch</span><span class="si">}</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">eta_dev</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">)</span>

        <span class="c1"># Correct by a factor 1/10 to minimize smearing for device states.</span>
        <span class="c1"># We want the electrode to smear.</span>
        <span class="n">eta_dev</span> <span class="o">/=</span> <span class="mi">10</span>

        <span class="c1"># Now we can estimate the device eta value.</span>
        <span class="c1"># It is based on the electrode values</span>
        <span class="n">eta_dev_tbt</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.Contours.Eta&quot;</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TS.Contours.nEq.Eta&quot;</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use passed option</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">eta_dev</span><span class="p">,</span> <span class="n">eta_dev_tbt</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf found inconsistent &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;imaginary eta from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">eta_dev_tbt</span><span class="si">}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">eta_dev</span><span class="si">}</span><span class="s2"> eV&quot;</span>
            <span class="p">)</span>

        <span class="n">elecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">elec_data</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                    <span class="n">tbtse</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;could not find file </span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc &quot;</span>
                        <span class="s2">&quot;but it was requested by &#39;use_tbt_se&#39;!&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># shift according to potential</span>
            <span class="n">data</span><span class="o">.</span><span class="n">Helec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">RecursiveSI</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Helec</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">semi_inf</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span>

            <span class="c1"># Limit connections of the device along the semi-inf directions</span>
            <span class="c1"># TODO check whether there are systems where it is important</span>
            <span class="c1"># we do all set_nsc before passing it for each electrode.</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;abc&quot;</span><span class="p">[</span><span class="n">se</span><span class="o">.</span><span class="n">semi_inf</span><span class="p">]:</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">Hdev</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="n">elec_se</span> <span class="o">=</span> <span class="n">PivotSelfEnergy</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">tbtse</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elec_se</span> <span class="o">=</span> <span class="n">DownfoldSelfEnergy</span><span class="p">(</span>
                    <span class="n">elec</span><span class="p">,</span>
                    <span class="n">se</span><span class="p">,</span>
                    <span class="n">tbt</span><span class="p">,</span>
                    <span class="n">Hdev</span><span class="p">,</span>
                    <span class="n">eta_device</span><span class="o">=</span><span class="n">eta_dev</span><span class="p">,</span>
                    <span class="n">bulk</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">bulk</span><span class="p">,</span>
                    <span class="n">bloch</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">elecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec_se</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Hdev</span><span class="p">,</span> <span class="n">elecs</span><span class="p">,</span> <span class="n">tbt</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeviceGreen.reset">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean any memory used by this object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_elec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a string electrode to the proper linear index&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iel</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">elec</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">iel</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elec</span>

    <span class="k">def</span> <span class="nf">_elec_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an electrode index or str to the name of the electrode&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">elec</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">elec</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">_check_Ek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="c1"># we have already prepared the calculation</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># while resetting is not necessary, it can</span>
        <span class="c1"># save a lot of memory since some arrays are not</span>
        <span class="c1"># temporarily stored twice.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ec</span> <span class="o">=</span> <span class="n">E</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ec</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_prepare_se</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span>

        <span class="c1"># Create all self-energies (and store the Gamma&#39;s)</span>
        <span class="n">se</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="c1"># Insert values</span>
            <span class="n">SE</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
            <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">se2broadening</span><span class="p">(</span><span class="n">SE</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="n">se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

    <span class="k">def</span> <span class="nf">_prepare_tgamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;tgamma&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cutoff</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma_cutoff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-13</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="c1"># ensure we have the self-energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_se</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># Get the sqrt of the level broadening matrix</span>
        <span class="k">def</span> <span class="nf">eigh_sqrt</span><span class="p">(</span><span class="n">gam</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
            <span class="n">eig</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">eig</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">emath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eig</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">eig</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="n">tgamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">:</span>
            <span class="n">tgamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigh_sqrt</span><span class="p">(</span><span class="n">gam</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma</span> <span class="o">=</span> <span class="n">tgamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>

    <span class="k">def</span> <span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">E</span>
        <span class="c1"># device region: E + 1j*eta</span>
        <span class="n">Ec</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Ec</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">k</span>

        <span class="c1"># Prepare the Green function calculation</span>
        <span class="n">inv_G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="p">)</span>

        <span class="c1"># Now reduce the sparse matrix to the device region (plus do the pivoting)</span>
        <span class="n">inv_G</span> <span class="o">=</span> <span class="n">inv_G</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">]</span>

        <span class="c1"># Create all self-energies (and store the Gamma&#39;s)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="c1"># Insert values</span>
            <span class="n">SE</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">inv_G</span><span class="p">[</span><span class="n">elec</span><span class="o">.</span><span class="n">pvt_dev</span><span class="p">,</span> <span class="n">elec</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">-=</span> <span class="n">SE</span>
            <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">se2broadening</span><span class="p">(</span><span class="n">SE</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">SE</span>
        <span class="n">data</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Now we have all needed to calculate the inverse parts of the Green function</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>

        <span class="c1"># Now we can calculate everything</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># initial matrix A and C</span>
        <span class="n">iG</span> <span class="o">=</span> <span class="n">inv_G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
            <span class="c1"># rotate slices</span>
            <span class="n">sln</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="n">sl0</span> <span class="o">=</span> <span class="n">slp</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">iG</span> <span class="o">=</span> <span class="n">inv_G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>

            <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sln</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="c1"># and final matrix A and B</span>
        <span class="n">iG</span> <span class="o">=</span> <span class="n">inv_G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">A</span><span class="p">[</span><span class="n">nbm1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">B</span><span class="p">[</span><span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="c1"># clean-up, not used anymore</span>
        <span class="k">del</span> <span class="n">inv_G</span>

        <span class="n">data</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">data</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>
        <span class="n">data</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>

        <span class="c1"># Now do propagation forward, tilde matrices</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="c1"># \tilde Y</span>
        <span class="n">tY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># \tilde X</span>
        <span class="n">tX</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># \tilde Y</span>
            <span class="n">tY</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># \tilde X</span>
            <span class="n">tX</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">tX</span> <span class="o">=</span> <span class="n">tX</span>
        <span class="n">data</span><span class="o">.</span><span class="n">tY</span> <span class="o">=</span> <span class="n">tY</span>

    <span class="k">def</span> <span class="nf">_matrix_to_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ssp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">BM</span>

<div class="viewcode-block" id="DeviceGreen.Sk">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.Sk">[docs]</a>
    <span class="k">def</span> <span class="nf">Sk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;btd&quot;</span><span class="p">:</span>
                <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>

        <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_btd</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_to_btd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span></div>


<div class="viewcode-block" id="DeviceGreen.Hk">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.Hk">[docs]</a>
    <span class="k">def</span> <span class="nf">Hk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;btd&quot;</span><span class="p">:</span>
                <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>

        <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_btd</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_to_btd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span></div>


    <span class="k">def</span> <span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c1"># Figure out which blocks are requested</span>
        <span class="n">block1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">block2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">block1</span> <span class="o">==</span> <span class="n">block2</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">block1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">blocks</span>

<div class="viewcode-block" id="DeviceGreen.green">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.green">[docs]</a>
    <span class="k">def</span> <span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;array&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the Green function for a given `E` and `k` point</span>

<span class="sd">        The Green function is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf G(E,\mathbf k) = \big[\mathbf S(\mathbf k) E - \mathbf H(\mathbf k)</span>
<span class="sd">                  - \sum \boldsymbol \Sigma(E,\mathbf k)\big]^{-1}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        k : array_like, optional</span>
<span class="sd">           k-point to calculate the Green function at</span>
<span class="sd">        format : {&quot;array&quot;, &quot;btd&quot;, &quot;bm&quot;, &quot;bd&quot;, &quot;sparse&quot;}</span>
<span class="sd">           return the matrix in a specific format</span>

<span class="sd">           - array: a regular numpy array (full matrix)</span>
<span class="sd">           - btd: a block-matrix object with only the diagonals and first off-diagonals</span>
<span class="sd">           - bm: a block-matrix object with diagonals and all off-diagonals</span>
<span class="sd">           - bd: a block-matrix object with only diagonals (no off-diagonals)</span>
<span class="sd">           - sparse: a sparse-csr matrix for the sparse elements as found in the Hamiltonian</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;dense&quot;</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_green_</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green format not valid input [array|sparse|bm|btd|bd]&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_green_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function on a full np.array matrix&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">sumbs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">btd</span><span class="p">):</span>
            <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span><span class="p">)</span>

            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="c1"># Do above</span>
            <span class="n">next_sum</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Calculate all parts above</span>
                <span class="n">sla</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">next_sum</span> <span class="o">-</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">next_sum</span><span class="p">)</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sla</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="n">sla</span>
                <span class="n">next_sum</span> <span class="o">-=</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

            <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span><span class="p">)</span>

            <span class="c1"># Step block</span>
            <span class="n">sumbs</span> <span class="o">+=</span> <span class="n">bs</span>

            <span class="c1"># Do below</span>
            <span class="n">next_sum</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
                <span class="c1"># Calculate all parts above</span>
                <span class="n">sla</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">next_sum</span><span class="p">,</span> <span class="n">next_sum</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sla</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="n">sla</span>
                <span class="n">next_sum</span> <span class="o">+=</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only in the BTD matrix elements.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G11</span>
            <span class="c1"># do above</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G11</span>
            <span class="c1"># do below</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G11</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the full Green function.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_btd</span><span class="p">()</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="n">G0</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">G0</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">@</span> <span class="n">G0</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">bb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>
            <span class="n">G0</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">G0</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">@</span> <span class="n">G0</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">bb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_bd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only along the diagonal block matrices.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">BI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
            <span class="c1"># Calculate diagonal part</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="n">BI</span><span class="p">[</span><span class="n">nbm1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">nbm1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">nbm1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only in where the sparse H and S are non-zero.</span>

<span class="sd">        Stored in a `scipy.sparse.csr_matrix` class.&quot;&quot;&quot;</span>
        <span class="c1"># create a sparse matrix</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># pivot the matrix</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">]</span>

        <span class="c1"># Get row and column entries</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span>

        <span class="k">def</span> <span class="nf">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row_b</span><span class="p">,</span> <span class="n">col_b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">col_b</span> <span class="o">=</span> <span class="n">row_b</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">col_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">idx</span><span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">col_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">sumbsn</span><span class="p">,</span> <span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">btd</span><span class="p">):</span>
            <span class="n">sumbsp</span> <span class="o">=</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">bsp</span> <span class="o">=</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="c1"># get all entries where G is non-zero</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">GM</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="c1"># check if we should do block above</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbsn</span><span class="p">,</span> <span class="n">sumbs</span><span class="p">),</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">GM</span><span class="p">)[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbsn</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="c1"># check if we should do block below</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbsp</span><span class="p">,</span> <span class="n">sumbsp</span> <span class="o">+</span> <span class="n">bsp</span><span class="p">),</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">GM</span><span class="p">)[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbsp</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="n">bsn</span> <span class="o">=</span> <span class="n">bs</span>
            <span class="n">sumbsn</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">sumbs</span> <span class="o">+=</span> <span class="n">bs</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only on specific (neighboring) diagonal block matrices.</span>

<span class="sd">        Stored in a `np.array` class.&quot;&quot;&quot;</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Find parts we need to calculate</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> green(diagonal) requires maximally 2 blocks&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> green(diagonal) requires spanning only 2 blocks&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="c1"># Find the indices in the block</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

            <span class="n">b_idx</span> <span class="o">=</span> <span class="n">indices_only</span><span class="p">(</span><span class="n">arangei</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[</span>
                    <span class="p">:,</span> <span class="n">b_idx</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Now calculate the thing (below/above)</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Calculate below</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate above</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">G</span>

    <span class="k">def</span> <span class="nf">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the full Green function column for a subset of columns.</span>

<span class="sd">        Stored in a `np.array` class.&quot;&quot;&quot;</span>
        <span class="c1"># To calculate the full Gf for specific column indices</span>
        <span class="c1"># These indices should maximally be spanning 2 blocks</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Find parts we need to calculate</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green(column) requires maximally 2 blocks&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green(column) requires spanning only 2 blocks&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="c1"># Find the indices in the block</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

            <span class="n">b_idx</span> <span class="o">=</span> <span class="n">indices_only</span><span class="p">(</span><span class="n">arangei</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[</span>
                    <span class="p">:,</span> <span class="n">b_idx</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Now calculate above/below</span>

            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Calculate below</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate above</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>

        <span class="c1"># Now we can calculate the Gf column above</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl</span>

        <span class="c1"># All blocks below</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl</span>

        <span class="k">return</span> <span class="n">G</span>

<div class="viewcode-block" id="DeviceGreen.spectral">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.spectral">[docs]</a>
    <span class="k">def</span> <span class="nf">spectral</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">,</span>
        <span class="n">E</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span><span class="p">,</span>
        <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the spectral function for a given `E` and `k` point from a given electrode</span>

<span class="sd">        The spectral function is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak{e}}(E,\mathbf k) = \mathbf G(E,\mathbf k)\boldsymbol\Gamma_{\mathfrak{e}}(E,\mathbf k)</span>
<span class="sd">                   \mathbf G^\dagger(E,\mathbf k)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to calculate the spectral function from</span>
<span class="sd">        E : float</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        k : array_like, optional</span>
<span class="sd">           k-point to calculate the spectral function at</span>
<span class="sd">        format : {&quot;array&quot;, &quot;btd&quot;, &quot;bm&quot;, &quot;bd&quot;}</span>
<span class="sd">           return the matrix in a specific format</span>

<span class="sd">           - array: a regular numpy array (full matrix)</span>
<span class="sd">           - btd: a block-matrix object with only the diagonals and first off-diagonals</span>
<span class="sd">           - bm: a block-matrix object with diagonals and all off-diagonals</span>
<span class="sd">           - bd: same as btd, since they are already calculated</span>
<span class="sd">        method : {&quot;column&quot;, &quot;propagate&quot;}</span>
<span class="sd">           which method to use for calculating the spectral function.</span>
<span class="sd">           Depending on the size of the BTD blocks one may be faster than the</span>
<span class="sd">           other. For large systems you are recommended to time the different methods</span>
<span class="sd">           and stick with the fastest one, they are numerically identical.</span>
<span class="sd">        herm:</span>
<span class="sd">           The spectral function is a Hermitian matrix, by default (True), the methods</span>
<span class="sd">           that can utilize the Hermitian property only calculates the lower triangular</span>
<span class="sd">           part of :math:`\mathbf A`, and then copies the Hermitian to the upper part.</span>
<span class="sd">           By setting this to `False` the entire matrix is explicitly calculated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the herm flag is considered useful for testing, there is no need to</span>
        <span class="c1"># play with it. So it isn&#39;t documented.</span>

        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;dense&quot;</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;bd&quot;</span><span class="p">:</span>
            <span class="c1"># the bd also returns the off-diagonal ones since</span>
            <span class="c1"># they are needed to calculate the diagonal terms anyway.</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;btd&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_spectral_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.spectral combination of format+method not recognized </span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">+</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_spectral_column_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array (`herm` not used)&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="c1"># Now calculate the full spectral function</span>
        <span class="k">return</span> <span class="n">G</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_spectral_column_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array</span>

<span class="sd">        Returns a `BlockMatrix` class with all elements calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        herm: bool</span>
<span class="sd">           if true, only calculate the lower triangular part, and copy</span>
<span class="sd">           the Hermitian part to the upper triangular part.</span>
<span class="sd">           Else, calculate the full matrix via MM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>

        <span class="n">Gam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Now calculate the full spectral function</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">btd</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">return</span> <span class="n">btd</span>

    <span class="k">def</span> <span class="nf">_spectral_column_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array</span>

<span class="sd">        Returns a `BlockMatrix` class with only BTD blocks calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        herm: bool</span>
<span class="sd">           if true, only calculate the lower triangular part, and copy</span>
<span class="sd">           the Hermitian part to the upper triangular part.</span>
<span class="sd">           Else, calculate the full matrix via MM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>

        <span class="n">Gam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Now calculate the full spectral function</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">btd</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">jb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">return</span> <span class="n">btd</span>

    <span class="k">def</span> <span class="nf">_spectral_propagate_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="c1"># Allocate space for the full matrix</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">S</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="k">del</span> <span class="n">A</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">def</span> <span class="nf">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above left</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># below</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>
                <span class="c1"># left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above and left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span>
                        <span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="c1"># below and right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span>
                        <span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>
                <span class="c1"># right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">)]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="k">def</span> <span class="nf">_spectral_propagate_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above left</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># below</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>
                <span class="c1"># left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above and left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># below and right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">])</span>
                <span class="c1"># right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">BM</span>

    <span class="k">def</span> <span class="nf">_spectral_propagate_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">):</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

        <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="c1"># right</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># above</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dtY</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span> <span class="o">@</span> <span class="n">dtY</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">dtY</span>
            <span class="c1"># right</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BM</span>

    <span class="k">def</span> <span class="nf">_scattering_state_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;U on input is a fortran-index as returned from eigh or svd&quot;&quot;&quot;</span>
        <span class="c1"># Select only the first N components where N is the</span>
        <span class="c1"># number of orbitals in the electrode (there can&#39;t be</span>
        <span class="c1"># any more propagating states anyhow).</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">])</span>

        <span class="c1"># sort and take N highest values</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">DOS</span><span class="p">)[:</span><span class="n">N</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># also retain values with large negative DOS.</span>
            <span class="c1"># These should correspond to states with large weight, but in some</span>
            <span class="c1"># way unphysical. The DOS *should* be positive.</span>
            <span class="c1"># Here we do the normalization depending on the number of orbitals</span>
            <span class="c1"># that is touched. This is important to make a uniformly defined</span>
            <span class="c1"># cutoff that does not depend on the device size.</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">DOS</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">cutoff</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>

<div class="viewcode-block" id="DeviceGreen.scattering_state">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.scattering_state">[docs]</a>
    <span class="k">def</span> <span class="nf">scattering_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">,</span>
        <span class="n">E</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;svd:gamma&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the scattering states for a given `E` and `k` point from a given electrode</span>

<span class="sd">        The scattering states are the eigen states of the spectral function:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak e}(E,\mathbf k) \mathbf u_i = 2\pi a_i \mathbf u_i</span>

<span class="sd">        where :math:`a_i` is the DOS carried by the :math:`i`&#39;th scattering</span>
<span class="sd">        state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to calculate the spectral function from</span>
<span class="sd">        E : float</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        k : array_like, optional</span>
<span class="sd">           k-point to calculate the spectral function at</span>
<span class="sd">        cutoff : float, optional</span>
<span class="sd">           cutoff the returned scattering states at some DOS value. Any scattering states</span>
<span class="sd">           with normalized eigenvalues lower than `cutoff` are discarded.</span>
<span class="sd">           The normalization is done by dividing the eigenvalue with the number of orbitals</span>
<span class="sd">           in the device region. This normalization ensures the same cutoff value has roughly</span>
<span class="sd">           the same meaning for different size devices.</span>
<span class="sd">           Values above or close to 1e-5 should be used with care.</span>
<span class="sd">        method : {&quot;svd:gamma&quot;, &quot;svd:A&quot;, &quot;full&quot;}</span>
<span class="sd">           which method to use for calculating the scattering states.</span>
<span class="sd">           Use only the ``full`` method for testing purposes as it is extremely slow</span>
<span class="sd">           and requires a substantial amount of memory.</span>
<span class="sd">           The ``svd:gamma`` is the fastests while retaining complete precision.</span>
<span class="sd">           The ``svd:A`` may be even faster for very large systems with</span>
<span class="sd">           very little loss of precision, since it diagonalizes :math:`\mathbf A` in</span>
<span class="sd">           the subspace of the electrode `elec` and reduces the propagated part of the spectral</span>
<span class="sd">           matrix.</span>
<span class="sd">        cutoff_elec : float, optional</span>
<span class="sd">           Only used for ``method=svd:A``. The initial block of the spectral function is</span>
<span class="sd">           diagonalized and only eigenvectors with eigenvalues ``&gt;=cutoff_elec`` are retained,</span>
<span class="sd">           thus reducing the initial propagated modes. The normalization explained for `cutoff`</span>
<span class="sd">           also applies here.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scat : StateCElectron</span>
<span class="sd">           the scattering states from the spectral function. The ``scat.state`` contains</span>
<span class="sd">           the scattering state vectors (eigenvectors of the spectral function).</span>
<span class="sd">           ``scat.c`` contains the DOS of the scattering states scaled by :math:`1/(2\pi)`</span>
<span class="sd">           so ensure correct density of states.</span>
<span class="sd">           One may recreate the spectral function with ``scat.outer(matrix=scat.c * 2 * pi)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_scattering_state_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.scattering_state method is not [full,svd,propagate]&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_scattering_state_full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># We know that scattering_state has called prepare!</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># add something to the diagonal (improves diag precision for small states)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># Now diagonalize A</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># backconvert diagonal</span>
        <span class="n">DOS</span> <span class="o">-=</span> <span class="mf">0.1</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scattering_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span> <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span>
        <span class="p">)</span>

        <span class="c1"># always have the first state with the largest values</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scattering_state_svd_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># This calculation uses the cholesky decomposition of Gamma</span>
        <span class="c1"># combined with SVD of the A column</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Perform svd</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scattering_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;svd:Gamma&quot;</span><span class="p">,</span>
            <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span>
            <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># always have the first state with the largest values</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scattering_state_svd_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Parse the cutoff value</span>
        <span class="c1"># Here we may use 2 values, one for cutting off the initial space</span>
        <span class="c1"># and one for the returned space.</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cutoff</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cutoff0</span> <span class="o">=</span> <span class="n">cutoff1</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cutoff0</span><span class="p">,</span> <span class="n">cutoff1</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cutoff0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cutoff_elec&quot;</span><span class="p">,</span> <span class="n">cutoff0</span><span class="p">)</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="c1"># This is basically the same thing as calculating the Gf column</span>
        <span class="c1"># But only in the 1/2 diagonal blocks of Gf</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># Calculate the spectral function only for the blocks that host the</span>
        <span class="c1"># scattering matrix</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="c1"># add something to the diagonal (improves diag precision)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># Calculate eigenvalues</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="c1"># backconvert diagonal</span>
        <span class="n">DOS</span> <span class="o">-=</span> <span class="mf">0.1</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># Remove states for cutoff and size</span>
        <span class="c1"># Since there cannot be any addition of states later, we</span>
        <span class="c1"># can do the reduction here.</span>
        <span class="c1"># This will greatly increase performance for very wide systems</span>
        <span class="c1"># since the number of contributing states is generally a fraction</span>
        <span class="c1"># of the total electrode space.</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scattering_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">cutoff0</span><span class="p">)</span>
        <span class="c1"># Back-convert to retain scale of the vectors before SVD</span>
        <span class="c1"># and also take the sqrt to ensure u u^dagger returns</span>
        <span class="c1"># a sensible value, the 2*pi factor ensures the *original* scale.</span>
        <span class="n">u</span> <span class="o">*=</span> <span class="n">signsqrt</span><span class="p">(</span><span class="n">DOS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="c1"># Create full U</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">u</span>

        <span class="c1"># Propagate A in the full BTD matrix</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sln</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">sln</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">sln</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">slp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">slp</span>

        <span class="c1"># Perform svd</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scattering_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">)</span>

        <span class="c1"># Now we have the full u, create it and transpose to get it in C indexing</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;svd:A&quot;</span><span class="p">,</span>
            <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span>
            <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
            <span class="n">cutoff_elec</span><span class="o">=</span><span class="n">cutoff0</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

<div class="viewcode-block" id="DeviceGreen.scattering_matrix">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.scattering_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">scattering_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the scattering matrix (S-matrix) between `elec_from` and `elec_to`</span>

<span class="sd">        The scattering matrix is calculated as</span>

<span class="sd">        .. math::</span>
<span class="sd">               \mathbf S_{\mathfrak e_{\mathrm{to}}\mathfrak e_{\mathrm{from}} }(E, \mathbf) = -\delta_{\alpha\beta} + i</span>
<span class="sd">               \tilde{\boldsymbol\Gamma}_{\mathfrak e_{\mathrm{to}}}</span>
<span class="sd">               \mathbf G</span>
<span class="sd">               \tilde{\boldsymbol\Gamma}_{\mathfrak e_{\mathrm{from}}}</span>

<span class="sd">        Here :math:`\tilde{\boldsymbol\Gamma}` is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol\Gamma(E,\mathbf k) \mathbf u_i &amp;= \lambda_i \mathbf u_i</span>
<span class="sd">            \\</span>
<span class="sd">            \tilde{\boldsymbol\Gamma}(E,\mathbf k) &amp;= \operatorname{diag}\{ \sqrt{\boldsymbol\lambda} \} \mathbf u</span>

<span class="sd">        Once the scattering matrices have been calculated one can calculate the full transmission</span>
<span class="sd">        function</span>

<span class="sd">        .. math::</span>
<span class="sd">              T_{\mathfrak e_{\mathrm{from}}\mathfrak e_{\mathrm{to}} }(E, \mathbf k) = \operatorname{Tr}\big[</span>
<span class="sd">              \mathbf S_{\mathfrak e_{\mathrm{to}}\mathfrak e_{\mathrm{from}} }^\dagger</span>
<span class="sd">              \mathbf S_{\mathfrak e_{\mathrm{to}}\mathfrak e_{\mathrm{from}} }\big]</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from : str or int</span>
<span class="sd">           the electrode where the scattering matrix originates from</span>
<span class="sd">        elec_to : str or int or list of</span>
<span class="sd">           where the scattering matrix ends in.</span>
<span class="sd">        E : float</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        k : array_like, optional</span>
<span class="sd">           k-point to calculate the scattering matrix at</span>
<span class="sd">        cutoff : float, optional</span>
<span class="sd">           cutoff the eigen states of the broadening matrix that are below this value.</span>
<span class="sd">           I.e. only :math:`\lambda` values above this value will be used.</span>
<span class="sd">           A too high value will remove too many eigen states and results will be wrong.</span>
<span class="sd">           A small value improves precision at the cost of bigger matrices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scat_matrix : numpy.ndarray or tuple of numpy.ndarray</span>
<span class="sd">           for each `elec_to` a scattering matrix will be returned. Its dimensions will be</span>
<span class="sd">           depending on the `cutoff` value at the cost of precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the full column green function</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>

        <span class="n">is_single</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="p">(</span><span class="n">Integral</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">)):</span>
            <span class="n">is_single</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">elec_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">elec_to</span><span class="p">]</span>
        <span class="c1"># convert to indices</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">]</span>

        <span class="c1"># Prepare calculation @ E and k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_tgamma</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="c1"># Get full G in column of &#39;from&#39;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec_from</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># the \tilde \Gamma functions</span>
        <span class="n">tG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma</span>

        <span class="c1"># Now calculate the S matrices</span>
        <span class="k">def</span> <span class="nf">calc_S</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">jtgam_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">tgam_to</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span><span class="p">[</span><span class="n">elec_to</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tgam_to</span><span class="p">)</span> <span class="o">@</span> <span class="n">g</span> <span class="o">@</span> <span class="n">jtgam_from</span>
            <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
                <span class="n">min_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="n">min_n</span><span class="p">,</span> <span class="n">min_n</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">tgam_from</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">tG</span><span class="p">[</span><span class="n">elec_from</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">calc_S</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">tgam_from</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">tG</span><span class="p">[</span><span class="n">elec</span><span class="p">],</span> <span class="n">G</span><span class="p">)</span> <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="DeviceGreen.eigenchannel">
<a class="viewcode-back" href="../../../toolbox/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.eigenchannel">[docs]</a>
    <span class="k">def</span> <span class="nf">eigenchannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">ret_coeff</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the eigenchannel from scattering states entering electrodes `elec_to`</span>

<span class="sd">        The energy and k-point is inferred from the `state` object as returned from</span>
<span class="sd">        `scattering_state`.</span>

<span class="sd">        The eigenchannels are the eigen states of the transmission matrix in the</span>
<span class="sd">        DOS weighted scattering states:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak e_{\mathrm{from}} }(E,\mathbf k) \mathbf u_i &amp;= 2\pi a_i \mathbf u_i</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf t_{\mathbf u} &amp;= \sum \langle \mathbf u | \boldsymbol\Gamma_{ \mathfrak e_{\mathrm{to}} }  | \mathbf u\rangle</span>

<span class="sd">        where the eigenvectors of :math:`\mathbf t_{\mathbf u}` are the coefficients of the</span>
<span class="sd">        DOS weighted scattering states (:math:`\sqrt{2\pi a_i} u_i`) for the individual eigen channels.</span>
<span class="sd">        The eigenvalues are the transmission eigenvalues. Further details may be found in :cite:`Paulsson2007`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state : sisl.physics.StateCElectron</span>
<span class="sd">            the scattering states as obtained from `scattering_state`</span>
<span class="sd">        elec_to : str or int (list or not)</span>
<span class="sd">            which electrodes to consider for the transmission eigenchannel</span>
<span class="sd">            decomposition (the sum in the above equation)</span>
<span class="sd">        ret_coeff : bool, optional</span>
<span class="sd">            return also the scattering state coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        T_eig : sisl.physics.StateCElectron</span>
<span class="sd">            the transmission eigenchannels, the ``T_eig.c`` contains the transmission</span>
<span class="sd">            eigenvalues.</span>
<span class="sd">        coeff : sisl.physics.StateElectron</span>
<span class="sd">            coefficients of `state` that creates the transmission eigenchannels</span>
<span class="sd">            Only returned if `ret_coeff` is True. There is a one-to-one correspondance</span>
<span class="sd">            between ``coeff`` and ``T_eig`` (with a prefactor of :math:`\sqrt{2\pi}`).</span>
<span class="sd">            This is equivalent to the ``T_eig`` states in the scattering state basis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_se</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span> <span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="p">(</span><span class="n">Integral</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">)):</span>
            <span class="n">elec_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">elec_to</span><span class="p">]</span>
        <span class="c1"># convert to indices</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">]</span>

        <span class="c1"># The sign shouldn&#39;t really matter since the states should always</span>
        <span class="c1"># have a finite DOS, however, for completeness sake we retain the sign.</span>
        <span class="c1"># We scale the vectors by sqrt(DOS/2pi).</span>
        <span class="c1"># This is because the scattering states from self.scattering_state</span>
        <span class="c1"># stores eig(A) / 2pi.</span>
        <span class="n">sqDOS</span> <span class="o">=</span> <span class="n">signsqrt</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Retrive the scattering states `A` and apply the proper scaling</span>
        <span class="c1"># We need this scaling for the eigenchannel construction anyways.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state</span> <span class="o">*</span> <span class="n">sqDOS</span>

        <span class="c1"># create shorthands</span>
        <span class="n">elec_pvt_dev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs_pvt_dev</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span>

        <span class="c1"># Create the first electrode</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">elec_to</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">elec_pvt_dev</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Retrive the scattering states `A` and apply the proper scaling</span>
        <span class="c1"># We need this scaling for the eigenchannel construction anyways.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
        <span class="c1"># the summed transmission matrix</span>
        <span class="n">Ut</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">@</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># same for other electrodes</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">elec_pvt_dev</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">Ut</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">@</span> <span class="n">u</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># TODO currently a factor depends on what is used</span>
        <span class="c1">#      in `scattering_states`, so go check there.</span>
        <span class="c1">#      The resulting Ut should have a factor: 1 / 2pi ** 0.5</span>
        <span class="c1">#      When the states DOS values (`state.c`) has the factor 1 / 2pi</span>
        <span class="c1">#      then `u` has the correct magnitude and all we need to do is to add the factor 2pi</span>
        <span class="c1"># diagonalize the transmission matrix tt</span>
        <span class="n">tt</span><span class="p">,</span> <span class="n">Ut</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">Ut</span><span class="p">)</span>
        <span class="n">tt</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;elec_to&quot;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">)}</span>

        <span class="c1"># Backtransform U to form the eigenchannels</span>
        <span class="n">teig</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">Ut</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span><span class="p">,</span> <span class="n">tt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_coeff</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">teig</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">(</span><span class="n">Ut</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">teig</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2024, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>